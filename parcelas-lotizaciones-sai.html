<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>División Avanzada de Parcelas y Lotizaciones SAI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap"
    rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Colores Profesionales */
      --primary-color: #1e40af;
      --primary-hover: #1e3a8a;
      --primary-light: #3b82f6;
      --secondary-color: #64748b;
      --accent-color: #0ea5e9;
      --success-color: #059669;
      --danger-color: #dc2626;
      --warning-color: #d97706;
      --info-color: #0284c7;

      /* Fondos Elegantes */
      --background-primary: #0f172a;
      --background-secondary: #1e293b;
      --background-tertiary: #334155;
      --background-elevated: #475569;
      --surface-primary: rgba(255, 255, 255, 0.03);
      --surface-secondary: rgba(255, 255, 255, 0.06);
      --surface-hover: rgba(255, 255, 255, 0.08);

      /* Bordes y Líneas */
      --border-primary: rgba(255, 255, 255, 0.08);
      --border-secondary: rgba(255, 255, 255, 0.12);
      --border-accent: rgba(30, 64, 175, 0.3);

      /* Texto Profesional */
      --text-primary: #f8fafc;
      --text-secondary: #e2e8f0;
      --text-tertiary: #cbd5e1;
      --text-muted: #94a3b8;
      --text-accent: #60a5fa;

      /* Sombras Sofisticadas */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.15);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.25);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
      --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.4);

      /* Gradientes Profesionales */
      --gradient-primary: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
      --gradient-secondary: linear-gradient(135deg, #64748b 0%, #475569 100%);
      --gradient-success: linear-gradient(135deg, #059669 0%, #047857 100%);
      --gradient-warning: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      --gradient-accent: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
      --gradient-surface: linear-gradient(135deg, var(--surface-primary) 0%, var(--surface-secondary) 100%);

      /* Tipografía */
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      --font-heading: 'Inter', sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', monospace;
      --font-serif: 'Crimson Text', Georgia, serif;

      /* Espaciado Profesional */
      --spacing-xs: 0.25rem;
      --spacing-sm: 0.5rem;
      --spacing-md: 0.75rem;
      --spacing-lg: 1rem;
      --spacing-xl: 1.5rem;
      --spacing-2xl: 2rem;

      /* Bordes Redondeados */
      --radius-sm: 0.375rem;
      --radius-md: 0.5rem;
      --radius-lg: 0.75rem;
      --radius-xl: 1rem;
    }

    body {
      font-family: var(--font-primary);
      background: linear-gradient(135deg, var(--background-primary) 0%, var(--background-secondary) 100%);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: hidden;
      font-weight: 400;
      letter-spacing: -0.025em;
      line-height: 1.6;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* === HEADER PRINCIPAL === */
    .main-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: var(--gradient-primary);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 var(--spacing-2xl);
      z-index: 1000;
      box-shadow: var(--shadow-2xl);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border-accent);
    }

    .company-info {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .company-logo {
      font-size: 2rem;
      font-weight: 800;
      color: white;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      font-family: var(--font-heading);
      letter-spacing: -0.05em;
    }

    .company-details {
      display: flex;
      flex-direction: column;
    }

    .company-title {
      font-size: 1.25rem;
      font-weight: 700;
      color: white;
      line-height: 1.2;
      font-family: var(--font-heading);
      letter-spacing: -0.025em;
    }

    .company-subtitle {
      font-size: 0.875rem;
      color: rgba(255, 255, 255, 0.85);
      font-weight: 400;
      font-family: var(--font-primary);
    }

    .header-actions {
      display: flex;
      gap: var(--spacing-md);
      align-items: center;
    }

    .hidden {
      display: none;
    }

    .btn-home {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: var(--spacing-sm) var(--spacing-lg);
      border-radius: var(--radius-md);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      backdrop-filter: blur(10px);
      font-family: var(--font-primary);
    }

    .btn-home:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
      box-shadow: var(--shadow-lg);
    }

    /* === AJUSTAR CONTENIDO PRINCIPAL === */
    .container {
      margin-top: 70px;
      height: calc(100vh - 70px);
    }

    .sidebar {
      width: 350px;
      background: var(--background-secondary);
      border-right: 1px solid var(--border-secondary);
      padding: 0;
      overflow-y: auto;
      box-shadow: var(--shadow-2xl);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }

    .sidebar-content {
      padding: var(--spacing-2xl) var(--spacing-xl);
    }

    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      background: var(--background-primary);
    }

    /* === SECCIONES REORGANIZADAS === */
    .section-group {
      margin-bottom: var(--spacing-2xl);
    }

    .group-title {
      font-size: 0.95rem;
      font-weight: 700;
      color: var(--text-accent);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: var(--spacing-lg);
      padding-bottom: var(--spacing-sm);
      border-bottom: 2px solid var(--border-accent);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-heading);
    }

    .section {
      margin-bottom: var(--spacing-xl);
      background: var(--gradient-surface);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-primary);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter: blur(10px);
    }

    .section:hover {
      box-shadow: var(--shadow-lg);
      border-color: var(--border-secondary);
      transform: translateY(-1px);
    }

    .section-header {
      background: var(--gradient-secondary);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-bottom: 1px solid var(--border-primary);
    }

    .section-content {
      padding: var(--spacing-xl);
    }

    .section h3 {
      color: var(--text-primary);
      margin: 0;
      font-size: 0.9rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-heading);
      letter-spacing: -0.025em;
    }

    /* === CONTROLES DE SNAP MEJORADOS === */
    .snap-controls {
      background: linear-gradient(135deg, rgba(217, 119, 6, 0.08), rgba(217, 119, 6, 0.04));
      border: 1px solid rgba(217, 119, 6, 0.2);
      border-radius: var(--radius-md);
      padding: var(--spacing-lg);
      margin: var(--spacing-lg) 0;
      backdrop-filter: blur(10px);
    }

    .snap-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--warning-color);
      margin-bottom: var(--spacing-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-heading);
    }

    .snap-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-sm);
      font-size: 0.8rem;
      margin-bottom: var(--spacing-md);
    }

    .snap-option {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin: 0;
      padding: var(--spacing-sm);
      border-radius: var(--radius-sm);
      transition: background 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: var(--font-primary);
    }

    .snap-option:hover {
      background: var(--surface-hover);
    }

    .snap-option input {
      width: auto;
      margin: 0;
      accent-color: var(--warning-color);
    }

    /* === CONTROLES DE DIVISIÓN MEJORADOS === */
    .division-method {
      background: linear-gradient(135deg, rgba(5, 150, 105, 0.08), rgba(5, 150, 105, 0.04));
      border: 1px solid rgba(5, 150, 105, 0.2);
      border-radius: var(--radius-md);
      padding: var(--spacing-lg);
      margin: var(--spacing-lg) 0;
      backdrop-filter: blur(10px);
    }

    .method-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--success-color);
      margin-bottom: var(--spacing-md);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-heading);
    }

    /* === MODO INDIVIDUAL MEJORADO === */
    .individual-mode {
      background: linear-gradient(135deg, rgba(30, 64, 175, 0.08), rgba(30, 64, 175, 0.04));
      border: 2px solid var(--primary-color);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      margin-top: var(--spacing-xl);
      backdrop-filter: blur(10px);
    }

    .individual-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--primary-light);
      margin-bottom: var(--spacing-lg);
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-heading);
      letter-spacing: -0.025em;
    }

    /* === INPUTS Y CONTROLES === */
    .input-group {
      margin-bottom: var(--spacing-lg);
    }

    .input-group:last-child {
      margin-bottom: 0;
    }

    label {
      display: block;
      margin-bottom: var(--spacing-sm);
      color: var(--text-secondary);
      font-size: 0.85rem;
      font-weight: 500;
      font-family: var(--font-primary);
      letter-spacing: -0.025em;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: var(--spacing-md) var(--spacing-lg);
      border: 1px solid var(--border-primary);
      border-radius: var(--radius-md);
      background: var(--background-primary);
      color: var(--text-primary);
      font-size: 0.9rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: var(--font-primary);
      backdrop-filter: blur(10px);
    }

    /* === ESTILOS ESPECÍFICOS PARA SELECT === */
    select {
      cursor: pointer;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23cbd5e1' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
      background-position: right var(--spacing-md) center;
      background-repeat: no-repeat;
      background-size: 1.2em 1.2em;
      padding-right: 2.5rem;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    /* === PREVENIR ANIMACIONES EN SELECT === */
    select::before,
    select::after {
      display: none !important;
    }

    /* === ESTILOS PARA OPTIONS === */
    select option {
      background: var(--background-secondary);
      color: var(--text-primary);
      padding: var(--spacing-sm) var(--spacing-md);
      border: none;
      font-family: var(--font-primary);
    }

    select option:checked {
      background: var(--primary-color);
      color: white;
    }

    select option:hover {
      background: var(--surface-hover);
    }

    /* === WEBKIT ESPECÍFICO PARA BETTER STYLING === */
    select::-webkit-scrollbar {
      width: 8px;
    }

    select::-webkit-scrollbar-track {
      background: var(--background-primary);
    }

    select::-webkit-scrollbar-thumb {
      background: var(--secondary-color);
      border-radius: var(--radius-sm);
    }

    textarea {
      resize: vertical;
      min-height: 100px;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      line-height: 1.5;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
      background: rgba(30, 64, 175, 0.02);
    }

    /* === BOTONES PROFESIONALES === */
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-md) var(--spacing-lg);
      border: none;
      border-radius: var(--radius-md);
      background: var(--gradient-primary);
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-decoration: none;
      min-height: 42px;
      position: relative;
      overflow: hidden;
      font-family: var(--font-primary);
      letter-spacing: -0.025em;
      box-shadow: var(--shadow-sm);
    }

    /* === ANIMACIÓN SOLO PARA BOTONES, NO PARA SELECT === */
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    button:hover::before {
      left: 100%;
    }

    /* === EXCLUIR SELECT DE ANIMACIONES DE BOTÓN === */
    select::before {
      display: none !important;
    }

    button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    button:active {
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* === VARIANTES DE BOTONES === */
    .btn-primary {
      background: var(--gradient-primary);
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-danger {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    .btn-success {
      background: var(--gradient-success);
    }

    .btn-success:hover {
      background: #047857;
    }

    .btn-warning {
      background: var(--gradient-warning);
    }

    .btn-warning:hover {
      background: #b45309;
    }

    .btn-secondary {
      background: var(--gradient-secondary);
      color: var(--text-primary);
    }

    .btn-secondary:hover {
      background: #475569;
    }

    .btn-info {
      background: var(--gradient-accent);
    }

    .btn-info:hover {
      background: #0284c7;
    }

    /* === GRUPOS DE BOTONES === */
    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-lg);
    }

    .button-group.full {
      grid-template-columns: 1fr;
    }

    .button-group.triple {
      grid-template-columns: 1fr 1fr 1fr;
    }

    .button-group.quad {
      grid-template-columns: 1fr 1fr 1fr 1fr;
    }

    /* === BARRA DE HERRAMIENTAS SUPERIOR === */
    .top-toolbar {
      background: var(--background-secondary);
      padding: var(--spacing-lg) var(--spacing-2xl);
      border-bottom: 1px solid var(--border-secondary);
      display: flex;
      gap: var(--spacing-lg);
      flex-wrap: wrap;
      align-items: center;
      box-shadow: var(--shadow-sm);
      backdrop-filter: blur(10px);
    }

    .toolbar-group {
      display: flex;
      gap: var(--spacing-sm);
      align-items: center;
      padding: 0 var(--spacing-lg);
      border-right: 1px solid var(--border-primary);
    }

    .toolbar-group:last-child {
      border-right: none;
      margin-left: auto;
    }

    .toolbar-help {
      color: var(--text-tertiary);
      font-size: 0.8rem;
      font-style: normal;
      font-family: var(--font-primary);
    }

    /* === CANVAS === */
    .canvas-container {
      flex: 1;
      position: relative;
      background: #000;
      overflow: hidden;
    }

    canvas {
      display: block;
      cursor: crosshair;
      background: linear-gradient(rgba(30, 64, 175, 0.08) 1px, transparent 1px),
        linear-gradient(90deg, rgba(30, 64, 175, 0.08) 1px, transparent 1px),
        radial-gradient(circle at 30% 30%,
          rgba(30, 64, 175, 0.03) 0%,
          rgba(0, 0, 0, 0.97) 70%);
      background-size: 25px 25px, 25px 25px, 100% 100%;
    }

    /* === PANELES DE INFORMACIÓN === */
    .info-panel {
      background: var(--background-primary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-primary);
      overflow: hidden;
      backdrop-filter: blur(10px);
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--border-primary);
      font-size: 0.85rem;
      font-family: var(--font-primary);
    }

    .info-item:last-child {
      border-bottom: none;
    }

    .info-item span:first-child {
      color: var(--text-tertiary);
      font-weight: 500;
    }

    .info-item span:last-child {
      color: var(--success-color);
      font-weight: 600;
      font-family: var(--font-mono);
    }

    /* === LISTADOS === */
    .polygon-list {
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: var(--spacing-lg);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-primary);
    }

    .polygon-item {
      background: var(--background-primary);
      padding: var(--spacing-md) var(--spacing-lg);
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border-bottom: 1px solid var(--border-primary);
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      font-family: var(--font-primary);
    }

    .polygon-item:last-child {
      border-bottom: none;
    }

    .polygon-item:hover {
      background: var(--surface-hover);
    }

    .polygon-item.active {
      background: rgba(30, 64, 175, 0.12);
      color: var(--primary-light);
      font-weight: 600;
    }

    .results {
      max-height: 240px;
      overflow-y: auto;
      margin-bottom: var(--spacing-lg);
    }

    .result-item {
      background: var(--background-primary);
      padding: var(--spacing-md) var(--spacing-lg);
      margin-bottom: var(--spacing-sm);
      border-radius: var(--radius-md);
      border-left: 4px solid var(--primary-color);
      font-size: 0.85rem;
      font-family: var(--font-primary);
    }

    /* === CONTROLES AUXILIARES === */
    .auxiliary-line-controls {
      display: none;
      margin-top: var(--spacing-lg);
      padding: var(--spacing-lg);
      background: var(--background-primary);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-primary);
      backdrop-filter: blur(10px);
    }

    #segmentInfo {
      padding: var(--spacing-sm);
      background: rgba(217, 119, 6, 0.08);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(217, 119, 6, 0.2);
      margin-top: var(--spacing-sm);
      font-size: 0.8rem;
      text-align: center;
      color: var(--warning-color);
      font-family: var(--font-primary);
    }

    /* === PROGRESO === */
    .progress-bar {
      width: 100%;
      height: 10px;
      background: var(--background-primary);
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin: var(--spacing-lg) 0;
      border: 1px solid var(--border-primary);
    }

    .progress-fill {
      height: 100%;
      background: var(--gradient-success);
      width: 0%;
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* === STATUS === */
    .status {
      text-align: center;
      padding: var(--spacing-md) var(--spacing-lg);
      border-radius: var(--radius-md);
      margin-top: var(--spacing-lg);
      font-size: 0.85rem;
      font-weight: 500;
      font-family: var(--font-primary);
    }

    .status.success {
      background: rgba(5, 150, 105, 0.08);
      color: var(--success-color);
      border: 1px solid rgba(5, 150, 105, 0.2);
    }

    .status.error {
      background: rgba(220, 38, 38, 0.08);
      color: var(--danger-color);
      border: 1px solid rgba(220, 38, 38, 0.2);
    }

    .status.warning {
      background: rgba(217, 119, 6, 0.08);
      color: var(--warning-color);
      border: 1px solid rgba(217, 119, 6, 0.2);
    }

    /* === ESTILOS PARA SNAP === */
    .snap-point {
      fill: #10b981;
      stroke: #ffffff;
      stroke-width: 2;
      filter: drop-shadow(0 0 4px #10b981);
    }

    .snap-midpoint {
      fill: #f59e0b;
      stroke: #ffffff;
      stroke-width: 2;
      filter: drop-shadow(0 0 4px #f59e0b);
    }

    .snap-endpoint {
      fill: #ef4444;
      stroke: #ffffff;
      stroke-width: 2;
      filter: drop-shadow(0 0 4px #ef4444);
    }

    .snap-preview {
      stroke: #10b981;
      stroke-width: 3;
      stroke-dasharray: 6, 6;
      fill: none;
      opacity: 0.9;
    }

    #centerViewBtn {
      display: none;
    }

    .snap-indicator {
      position: fixed;
      top: 90px;
      right: var(--spacing-2xl);
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: var(--spacing-sm) var(--spacing-lg);
      border-radius: var(--radius-md);
      font-size: 0.8rem;
      z-index: 1000;
      display: none;
      border: 1px solid var(--border-secondary);
      font-family: var(--font-primary);
      backdrop-filter: blur(10px);
    }

    /* === TOOLTIPS === */
    .tooltip {
      position: relative;
      cursor: help;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 130%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--background-primary);
      color: var(--text-primary);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      border: 1px solid var(--border-secondary);
      box-shadow: var(--shadow-lg);
      font-family: var(--font-primary);
    }

    .tooltip:hover::after {
      opacity: 1;
    }

    /* === SCROLLBARS === */
    .sidebar::-webkit-scrollbar,
    .polygon-list::-webkit-scrollbar,
    .results::-webkit-scrollbar {
      width: 8px;
    }

    .sidebar::-webkit-scrollbar-track,
    .polygon-list::-webkit-scrollbar-track,
    .results::-webkit-scrollbar-track {
      background: var(--background-primary);
    }

    .sidebar::-webkit-scrollbar-thumb,
    .polygon-list::-webkit-scrollbar-thumb,
    .results::-webkit-scrollbar-thumb {
      background: var(--secondary-color);
      border-radius: var(--radius-sm);
    }

    .sidebar::-webkit-scrollbar-thumb:hover,
    .polygon-list::-webkit-scrollbar-thumb:hover,
    .results::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* === EXPORTACIÓN === */
    .export-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-sm);
    }

    /* === HELP TEXT === */
    .help-text {
      margin-top: var(--spacing-lg);
      padding: var(--spacing-lg);
      background: rgba(2, 132, 199, 0.08);
      border: 1px solid rgba(2, 132, 199, 0.2);
      border-radius: var(--radius-md);
      font-size: 0.8rem;
      color: var(--info-color);
      line-height: 1.6;
      font-family: var(--font-primary);
      backdrop-filter: blur(10px);
    }

    .help-text strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    /* === RESPONSIVO === */
    @media (max-width: 1400px) {
      .sidebar {
        width: 380px;
      }

      .company-subtitle {
        display: none;
      }
    }

    @media (max-width: 1200px) {
      .sidebar {
        width: 360px;
      }

      .button-group.quad {
        grid-template-columns: 1fr 1fr;
      }

      .snap-options {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 1024px) {
      .sidebar {
        width: 340px;
      }

      .main-header {
        padding: 0 var(--spacing-xl);
      }

      .top-toolbar {
        padding: var(--spacing-md) var(--spacing-xl);
      }
    }

    @media (max-width: 768px) {
      .main-header {
        padding: 0 var(--spacing-lg);
        height: 60px;
      }

      .container {
        margin-top: 60px;
        height: calc(100vh - 60px);
      }

      .company-details {
        display: none;
      }

      .container {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        height: 45vh;
        order: 2;
      }

      .main-content {
        order: 1;
        height: 55vh;
      }

      .top-toolbar {
        padding: var(--spacing-sm) var(--spacing-lg);
        flex-wrap: wrap;
      }

      .toolbar-group {
        padding: 0 var(--spacing-sm);
      }

      .toolbar-help {
        display: none;
      }

      .sidebar-content {
        padding: var(--spacing-xl) var(--spacing-lg);
      }
    }

    @media (max-width: 640px) {
      .main-header {
        padding: 0 var(--spacing-md);
      }

      .company-logo {
        font-size: 1.5rem;
      }

      .company-title {
        font-size: 1rem;
      }

      .btn-home {
        padding: var(--spacing-xs) var(--spacing-md);
        font-size: 0.8rem;
      }

      .section-content,
      .sidebar-content {
        padding: var(--spacing-lg) var(--spacing-md);
      }

      .button-group.triple {
        grid-template-columns: 1fr;
      }
    }

    /* === ANIMACIONES PROFESIONALES === */
    .section {
      animation: slideInUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .loading {
      position: relative;
      overflow: hidden;
    }

    .loading::after {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent);
      animation: shimmer 2s infinite;
    }

    /* === PREVENIR CONFLICTOS DE ANIMACIÓN EN INPUTS Y SELECTS === */
    input.loading::after,
    select.loading::after,
    textarea.loading::after {
      display: none !important;
    }

    @keyframes shimmer {
      0% {
        left: -100%;
      }

      100% {
        left: 100%;
      }
    }

    /* === MICRO-INTERACCIONES === */
    .section-group {
      animation: fadeIn 0.8s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* === ESTADOS DE FOCUS MEJORADOS === */
    button:focus-visible {
      outline: 2px solid var(--primary-light);
      outline-offset: 2px;
    }

    input:focus-visible,
    select:focus-visible,
    textarea:focus-visible {
      outline: 2px solid var(--primary-light);
      outline-offset: 2px;
    }

    /* === MEJORAS DE ACCESIBILIDAD === */
    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* === EFECTOS DE GLASSMORPHISM === */
    .section,
    .snap-controls,
    .division-method,
    .individual-mode {
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
    }

    /* === ESTADO HOVER PARA ELEMENTOS INTERACTIVOS === */
    .polygon-item,
    .info-item {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .info-item:hover {
      background: var(--surface-hover);
    }

    /* === MEJORAS EN LA TIPOGRAFÍA === */
    .section h3 {
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .company-title,
    .group-title,
    .individual-title {
      text-rendering: optimizeLegibility;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
  </style>
</head>

<body>
  <!-- HEADER PRINCIPAL -->
  <div class="main-header">
    <div class="company-info">
      <div class="company-logo">
        <img src="img/LOGO2.png" alt="Logo SAI" style="height:45px;">
      </div>
      <div class="company-details">
        <div class="company-title">Soluciones a la Ingeniería</div>
        <div class="company-subtitle">Sistema Avanzado de División de Parcelas y Lotizaciones</div>
      </div>
    </div>
    <div class="header-actions">
      <a href="index." class="btn-home">🏠 Página Principal</a>
    </div>
  </div>

  <div class="container">
    <!-- SIDEBAR IZQUIERDO - Herramientas organizadas -->
    <div class="sidebar">
      <div class="sidebar-content">



        <!-- GRUPO 2: GESTIÓN DE POLÍGONOS -->
        <div class="section-group">
          <div class="group-title">
            <span>📋</span> Gestión de Polígonos
          </div>

          <!-- Lista de Polígonos -->
          <div class="section">
            <div class="section-header">
              <h3>📝 Polígonos Creados</h3>
            </div>
            <div class="section-content">
              <div class="polygon-list" id="polygonList"></div>
              <div class="button-group">
                <button id="deletePolygonBtn" class="btn-danger">🗑️ Eliminar</button>
                <button id="closePolygonBtn" class="btn-warning">🔗 Cerrar</button>
              </div>
            </div>
          </div>

          <!-- Información del Polígono -->
          <div class="section">
            <div class="section-header">
              <h3>📐 Información Actual</h3>
            </div>
            <div class="section-content">
              <div class="info-panel">
                <div class="info-item">
                  <span>Puntos:</span>
                  <span id="pointCount">0</span>
                </div>
                <div class="info-item">
                  <span>Área:</span>
                  <span id="totalArea">0.000 m²</span>
                </div>
                <div class="info-item">
                  <span>Perímetro:</span>
                  <span id="totalPerimeter">0.000 m</span>
                </div>
                <div class="info-item">
                  <span>Estado:</span>
                  <span id="isValid">-</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- GRUPO 3: CONFIGURACIÓN DE DIVISIÓN -->
        <div class="section-group">
          <div class="group-title">
            <span>🔪</span> Configuración de División
          </div>

          <!-- Método de División -->
          <div class="section">
            <div class="section-header">
              <h3>⚙️ Parámetros de División</h3>
            </div>
            <div class="section-content">
              <div class="division-method">
                <div class="method-title">🎯 Método de División</div>
                <div class="input-group">
                  <label for="divisionMethod">Tipo de División:</label>
                  <select id="divisionMethod">
                    <option value="equal">Partes Iguales</option>
                    <option value="specific">Área Específica</option>
                  </select>
                </div>

                <div class="input-group" id="numPartsGroup">
                  <label for="numParts">Número de Partes:</label>
                  <input type="number" id="numParts" value="4" min="2" max="20" />
                </div>

                <div class="input-group" id="specificAreaGroup" style="display: none">
                  <label for="specificArea">Área por Lote (m²):</label>
                  <input type="number" id="specificArea" value="100" min="1" step="0.01" />
                </div>
              </div>

              <div class="input-group">
                <label for="divisionAxis">Dirección de División:</label>
                <select id="divisionAxis">
                  <option value="x">🔹 Vertical (Izq. → Der.)</option>
                  <option value="y">🔸 Horizontal (Arr. → Abj.)</option>
                  <option value="auxiliary">📏 Paralelo a Línea Auxiliar</option>
                  <option value="rotational">🔄 Rotacional</option>
                </select>
              </div>

              <div class="input-group">
                <label for="precision">Nivel de Precisión:</label>
                <select id="precision">
                  <option value="0.1">🟢 Baja (0.1m²)</option>
                  <option value="0.01" selected>🟡 Media (0.01m²)</option>
                  <option value="0.001">🟠 Alta (0.001m²)</option>
                  <option value="0.0001">🔴 Muy Alta (0.0001m²)</option>
                </select>
              </div>

              <div class="button-group full">
                <button id="divideBtn" class="btn-success">
                  🔪 Ejecutar División
                </button>
              </div>
            </div>
          </div>

          <!-- Líneas Auxiliares -->
          <div class="section">
            <div class="section-header">
              <h3>📏 Líneas Auxiliares</h3>
            </div>
            <div class="section-content">
              <div class="auxiliary-line-controls" id="auxiliaryLineControls">
                <div class="button-group">
                  <button id="drawAuxiliaryBtn" class="btn-warning">📏 Dibujar Línea</button>
                  <button id="selectSegmentBtn" class="btn-warning">📐 Usar Segmento</button>
                </div>
                <div class="button-group full">
                  <button id="clearAuxiliaryBtn" class="btn-danger">🗑️ Limpiar Auxiliares</button>
                </div>
                <div id="segmentInfo" style="display: none;">
                  Click en un segmento del polígono para usarlo como referencia
                </div>


              </div>
              <!-- Agregar este div después de auxiliaryLineControls -->
              <div id="rotationalControls" style="display: none;">
                <div class="info-panel">
                  <h4>🔄 División Rotatoria</h4>
                  <p>Divide usando una línea que rota alrededor de un punto fijo.</p>
                  <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="setRotationalCenterBtn" class="btn btn-primary">
                      🎯 Establecer Centro
                    </button>
                    <button id="clearRotationalCenterBtn" class="btn btn-secondary">
                      ❌ Limpiar Centro
                    </button>
                  </div>
                  <div id="rotationalCenterInfo" style="margin-top: 10px; font-size: 12px; color: #888;">
                    Centro no establecido
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- GRUPO 4: MODO INDIVIDUAL -->
        <div class="section-group">
          <div class="group-title">
            <span>🎯</span> Creación Individual
          </div>

          <div class="section">
            <div class="section-header">
              <h3>🎯 Modo Individual de Lotes</h3>
            </div>
            <div class="section-content">
              <div class="button-group full">
                <button id="createIndividualLotBtn" class="btn-primary">
                  🎯 Activar Modo Individual
                </button>
              </div>

              <!-- Panel del Modo Individual -->
              <div id="individualLotPanel" class="individual-mode" style="display: none;">
                <div class="individual-title">🎯 Creación Individual Activa</div>

                <div id="remainingPolygonInfo" class="info-panel" style="margin-bottom: var(--spacing-lg);">
                  <!-- Se actualiza dinámicamente -->
                </div>

                <div class="input-group">
                  <label for="individualLotArea">Área del Lote (m²):</label>
                  <input type="number" id="individualLotArea" step="0.000001" min="0" placeholder="Ej: 250.50">
                </div>

                <div class="input-group">
                  <label for="individualDivisionAxis">Eje de División:</label>
                  <select id="individualDivisionAxis">
                    <option value="x">🔹 Vertical (X)</option>
                    <option value="y">🔸 Horizontal (Y)</option>
                    <option value="auxiliary">📏 Línea Auxiliar</option>
                  </select>
                </div>

                <div class="button-group full">
                  <button onclick="polygonDivider.createSingleLot()" class="btn-success">
                    ➕ Calcular Lote
                  </button>
                </div>

                <!-- Controles de Confirmación -->
                <div id="lotCreationControls"
                  style="display: none; margin-top: var(--spacing-lg); padding: var(--spacing-lg); border: 1px solid var(--success-color); border-radius: var(--radius-md); background: rgba(5, 150, 105, 0.06);">
                  <div id="pendingLotInfo" class="info-panel" style="margin-bottom: var(--spacing-lg);">
                    <!-- Se actualiza dinámicamente -->
                  </div>

                  <div class="button-group">
                    <button id="confirmIndividualLotBtn" class="btn-success">
                      ✅ Confirmar Lote
                    </button>
                    <button id="cancelIndividualLotBtn" class="btn-warning">
                      ❌ Cancelar
                    </button>
                  </div>

                  <div class="button-group full">
                    <button onclick="polygonDivider.updateLotPreview()" class="btn-info">
                      🔄 Recalcular Preview
                    </button>
                  </div>
                </div>

                <!-- Controles de Historial -->
                <div class="button-group" style="margin-top: var(--spacing-lg);">
                  <button id="undoIndividualLotBtn" class="btn-secondary">
                    ↶ Deshacer Último
                  </button>
                  <button id="finishIndividualModeBtn" class="btn-danger">
                    🏁 Finalizar Modo
                  </button>
                </div>

                <div class="help-text">
                  <strong>💡 Guía de Uso:</strong><br>
                  1️⃣ Ingrese el área deseada para el lote<br>
                  2️⃣ Seleccione el eje de división<br>
                  3️⃣ Click en "Calcular Lote" para ver preview<br>
                  4️⃣ Confirme o cancele el lote<br>
                  5️⃣ Repita para crear más lotes<br>
                  6️⃣ Use "Deshacer" si comete un error<br>
                  7️⃣ "Finalizar Modo" cuando termine
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- GRUPO 5: PROGRESO Y RESULTADOS -->
        <div class="section-group">
          <div class="group-title">
            <span>📊</span> Progreso y Resultados
          </div>

          <!-- Progreso -->
          <div class="section">
            <div class="section-header">
              <h3>📈 Estado del Proceso</h3>
            </div>
            <div class="section-content">
              <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
              </div>
              <div id="progressText"
                style="font-size: 0.85rem; color: var(--text-tertiary); text-align: center; margin-top: var(--spacing-sm); font-family: var(--font-primary);">
                Listo para dividir polígono
              </div>
              <div id="statusMessage"></div>
            </div>
          </div>

          <!-- Resultados -->
          <div class="section">
            <div class="section-header">
              <h3>📋 Resultados de División</h3>
            </div>
            <div class="section-content">
              <div class="results" id="results"></div>

              <div class="export-buttons" id="exportButtons" style="display: none; margin-bottom: var(--spacing-lg);">
                <button id="exportDxfBtn" class="btn-secondary">📐 Exportar DXF</button>
                <button id="exportTxtBtn" class="btn-secondary">📄 Exportar TXT</button>
              </div>

              <div class="button-group">
                <button id="convertAllBtn" class="btn-warning">📝 Convertir Todas</button>
                <button id="exportAllDxfBtn" class="btn-secondary">📐 Exportar Todos</button>
              </div>

              <div class="button-group full">
                <button id="showHierarchyBtn" class="btn-info">🌳 Ver Jerarquía</button>
              </div>
            </div>
          </div>
        </div>
        <!-- GRUPO 1: CREACIÓN DE POLÍGONOS -->
        <div class="section-group">
          <div class="group-title">
            <span>🎨</span> Creación de Polígonos
          </div>

          <!-- Nuevo Polígono -->
          <div class="section">
            <div class="section-header">
              <h3>✏️ Nuevo Polígono</h3>
            </div>
            <div class="section-content">
              <div class="button-group full">
                <button id="newPolygonBtn" class="btn-success">
                  ➕ Crear Polígono
                </button>
              </div>

              <!-- Configuración de Snap -->
              <div class="snap-controls">
                <div class="snap-title">🎯 Sistema de Snap</div>
                <div class="snap-options">
                  <label class="snap-option">
                    <input type="checkbox" id="snapEnabled" checked>
                    <span>🔧 Activar Snap</span>
                  </label>
                  <label class="snap-option">
                    <input type="checkbox" id="snapVertex" checked>
                    <span>🔴 Vértices</span>
                  </label>
                  <label class="snap-option">
                    <input type="checkbox" id="snapMidpoint" checked>
                    <span>🟡 Puntos Medios</span>
                  </label>
                  <label class="snap-option">
                    <input type="checkbox" id="snapGrid">
                    <span>📐 Grilla</span>
                  </label>
                </div>
                <div class="input-group">
                  <label for="snapTolerance">Tolerancia de Snap:</label>
                  <input type="range" id="snapTolerance" min="5" max="30" value="15">
                  <div
                    style="text-align: center; font-size: 0.8rem; color: var(--warning-color); margin-top: var(--spacing-xs);">
                    <span id="snapToleranceValue">15px</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Importación -->
          <div class="section">
            <div class="section-header">
              <h3>📥 Importar Datos</h3>
            </div>
            <div class="section-content">
              <div class="input-group">
                <label for="coordinatesInput">Coordenadas (X,Y por línea):</label>
                <textarea id="coordinatesInput"
                  placeholder="100.50,200.75&#10;150.25,300.00&#10;200.00,250.50"></textarea>
              </div>
              <div class="input-group">
                <label for="fileInput">Archivo TXT/DXF:</label>
                <input type="file" id="fileInput" accept=".txt,.dxf" />
              </div>
              <div class="button-group full">
                <button id="importCoordinatesBtn" class="btn-warning">
                  📥 Importar Coordenadas
                </button>
              </div>
            </div>
          </div>

          <div class="control-group hidden">
            <label for="curveResolution">Resolución de Curvas:</label>
            <div style="display: flex; gap: 10px; align-items: center;">
              <input type="range" id="curveResolution" min="8" max="200" value="50" style="flex: 1;">
              <span id="curveResolutionValue">50</span>
              <button type="button" id="applyCurveResolutionBtn" class="btn btn-sm btn-secondary"
                title="Aplicar nueva resolución a curvas existentes">
                Aplicar
              </button>
            </div>
            <small>Mayor resolución = más puntos en las curvas (más precisión, más procesamiento)</small>
          </div>

          <div class="info-panel hidden" style="margin-top: 10px;">
            <h4>Curvas DXF Soportadas:</h4>
            <ul style="font-size: 12px; margin: 5px 0;">
              <li><strong>POLYLINE/LWPOLYLINE</strong> - Con bulges (arcos)</li>
              <li><strong>ARC</strong> - Arcos circulares</li>
              <li><strong>CIRCLE</strong> - Círculos completos</li>
              <li><strong>ELLIPSE</strong> - Elipses completas o parciales</li>
              <li><strong>SPLINE</strong> - Curvas suaves interpoladas</li>
              <li><strong>LINE</strong> - Líneas rectas</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- INDICADOR DE SNAP -->
    <div id="snapIndicator" class="snap-indicator"></div>

    <!-- ÁREA PRINCIPAL - Canvas con controles superiores -->
    <div class="main-content">

      <!-- BARRA DE HERRAMIENTAS SUPERIOR -->
      <div class="top-toolbar">
        <div class="toolbar-group">
          <button id="clearBtn" class="btn-danger">🗑️ Limpiar Todo</button>
          <button id="undoBtn" class="btn-secondary">↶ Deshacer</button>
        </div>

        <div class="toolbar-group">
          <button id="toggleDimensionsBtn" class="btn-secondary">📏 Dimensiones</button>
          <button id="toggleGridBtn" class="btn-secondary">📐 Mostrar Grid</button>
        </div>

        <div class="toolbar-group">
          <button id="zoomFitBtn" class="btn-secondary">🔍 Ajustar Vista</button>
          <button id="centerViewBtn" class="btn-secondary">🎯 Centrar Vista</button>
        </div>

        <div class="toolbar-group">
          <div class="toolbar-help">

          </div>
        </div>
      </div>

      <!-- CANVAS DE DIBUJO -->
      <div class="canvas-container">
        <canvas id="canvas"></canvas>
      </div>

    </div>
  </div>
  <script>
    class AdvancedPolygonDivider {
      constructor() {
        this.canvas = document.getElementById("canvas");
        this.ctx = this.canvas.getContext("2d");
        this.polygons = [];
        this.activePolygonIndex = -1;
        this.auxiliaryLine = null;
        this.isDrawingAuxiliary = false;
        this.auxiliaryStart = null;
        this.individualLotMode = false;
        this.pendingLotArea = 0;
        this.tempPolygonForIndividual = null;
        this.individualLotHistory = []; // Para deshacer operaciones
        this.currentIndividualStep = 0;
        // === NUEVAS PROPIEDADES PARA SISTEMA DE SNAP ===
        this.snapEnabled = true;
        this.snapVertex = true;
        this.snapMidpoint = true;
        this.snapGrid = false;
        this.snapTolerance = 15; // en píxeles
        this.currentSnapPoint = null;
        this.snapPoints = []; // Cache de puntos de snap
        this.snapIndicator = null;
        this.previewLine = null;
        this.rotationalCenter = null;
        this.isSettingRotationalCenter = false;
        this.rotationalRadius = 1000; // Radio de la línea de corte
        this.maxRotationalIterations = 8000;
        this.rotationalTolerance = 1e-10;
        this.rotationalConvergence = 0.001;
        // Cambio importante: divisiones por polígono
        this.polygonDivisions = new Map(); // Map de polygonId -> divisions
        this.polygonHierarchy = new Map(); // parentId -> [childIds]
        this.polygonParents = new Map(); // childId -> parentId
        this.isDragging = false;
        this.isDraggingCanvas = false;
        this.dragIndex = -1;
        this.showGrid = true;
        this.showDimensions = true;
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.totalIterations = 0;
        this.curveResolution = 50; // Número de segmentos para interpolación de curvas
        this.supportedCurveTypes = ['ARC', 'CIRCLE', 'ELLIPSE', 'SPLINE'];
        this.curveData = new Map(); // Para almacenar datos de curvas originales
        this.lastMousePos = { x: 0, y: 0 };
        this.isSelectingSegment = false;
        this.selectedSegment = null;
        this.hoveredSegment = null;
        this.setupCanvas();
        this.setupEventListeners();
        this.createNewPolygon();
        this.animate();
        window.polygonDivider = this; // Para acceso desde botones HTML
      }
      setupCanvas() {
        this.resizeCanvas();
        window.addEventListener("resize", () => this.resizeCanvas());
      }
      resizeCanvas() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        this.draw();
      }
      setupEventListeners() {
        // Canvas events
        this.canvas.addEventListener("click", (e) => this.handleClick(e));
        this.canvas.addEventListener("contextmenu", (e) =>
          this.handleRightClick(e)
        );
        this.canvas.addEventListener("mousedown", (e) =>
          this.handleMouseDown(e)
        );
        this.canvas.addEventListener("mousemove", (e) =>
          this.handleMouseMove(e)
        );
        this.canvas.addEventListener("mouseup", () => this.handleMouseUp());
        this.canvas.addEventListener("wheel", (e) => this.handleWheel(e));
        // === EVENT LISTENERS PARA CONTROL DE CURVAS ===
        document.getElementById('curveResolution').addEventListener('input', (e) => {
          const resolution = e.target.value;
          document.getElementById('curveResolutionValue').textContent = resolution;
        });
        document.getElementById('applyCurveResolutionBtn').addEventListener('click', () => {
          const resolution = document.getElementById('curveResolution').value;
          this.setCurveResolution(resolution);
        });
        // === NUEVOS EVENT LISTENERS PARA CREACIÓN INDIVIDUAL ===
        document
          .getElementById("createIndividualLotBtn")
          .addEventListener("click", () => this.startIndividualLotCreation());
        document
          .getElementById("confirmIndividualLotBtn")
          .addEventListener("click", () => this.confirmIndividualLot());
        document
          .getElementById("cancelIndividualLotBtn")
          .addEventListener("click", () => this.cancelIndividualLot());
        document
          .getElementById("undoIndividualLotBtn")
          .addEventListener("click", () => this.undoLastIndividualLot());
        document
          .getElementById("finishIndividualModeBtn")
          .addEventListener("click", () => this.finishIndividualMode());
        // === NUEVOS EVENT LISTENERS PARA DIVISIÓN ROTATORIA ===
        document
          .getElementById("setRotationalCenterBtn")
          .addEventListener("click", () => this.startSettingRotationalCenter());
        document
          .getElementById("clearRotationalCenterBtn")
          .addEventListener("click", () => this.clearRotationalCenter());
        // === NUEVOS EVENT LISTENERS PARA SNAP ===
        document.getElementById('snapEnabled').addEventListener('change', (e) => {
          this.snapEnabled = e.target.checked;
          this.updateSnapPoints();
        });
        document.getElementById('snapVertex').addEventListener('change', (e) => {
          this.snapVertex = e.target.checked;
          this.updateSnapPoints();
        });
        document.getElementById('snapMidpoint').addEventListener('change', (e) => {
          this.snapMidpoint = e.target.checked;
          this.updateSnapPoints();
        });
        document.getElementById('snapGrid').addEventListener('change', (e) => {
          this.snapGrid = e.target.checked;
          this.updateSnapPoints();
        });
        document.getElementById('snapTolerance').addEventListener('input', (e) => {
          this.snapTolerance = parseInt(e.target.value);
          document.getElementById('snapToleranceValue').textContent = `${this.snapTolerance}px`;
        });
        // UI controls
        document
          .getElementById("newPolygonBtn")
          .addEventListener("click", () => this.createNewPolygon());
        document
          .getElementById("deletePolygonBtn")
          .addEventListener("click", () => this.deleteActivePolygon());
        document
          .getElementById("importCoordinatesBtn")
          .addEventListener("click", () => this.handleImport());
        document
          .getElementById("fileInput")
          .addEventListener("change", (e) => this.handleFileImport(e));
        document
          .getElementById("exportDxfBtn")
          .addEventListener("click", () => this.exportDXF());
        document
          .getElementById("exportDxfBtn")
          .addEventListener("click", () => this.exportDXF());
        // NUEVOS EVENT LISTENERS
        document
          .getElementById("convertAllBtn")
          .addEventListener("click", () => this.convertAllDivisionsToPolygons());
        document
          .getElementById("showHierarchyBtn")
          .addEventListener("click", () => this.showPolygonHierarchy());
        document
          .getElementById("exportTxtBtn")
          .addEventListener("click", () => this.exportTXT());
        document
          .getElementById("exportAllDxfBtn")
          .addEventListener("click", () => this.exportAllDXF());
        document
          .getElementById("divisionMethod")
          .addEventListener("change", () => this.updateUI());
        document
          .getElementById("divisionAxis")
          .addEventListener("change", () => this.updateUI());
        document
          .getElementById("drawAuxiliaryBtn")
          .addEventListener("click", () => this.startDrawingAuxiliary());
        document
          .getElementById("clearAuxiliaryBtn")
          .addEventListener("click", () => this.clearAuxiliaryLine());
        document
          .getElementById("selectSegmentBtn")
          .addEventListener("click", () => this.startSelectingSegment());
        document
          .getElementById("divideBtn")
          .addEventListener("click", () => this.dividePolygon());
        document
          .getElementById("clearBtn")
          .addEventListener("click", () => this.clearAll());
        document
          .getElementById("undoBtn")
          .addEventListener("click", () => this.undoLastPoint());
        document
          .getElementById("closePolygonBtn")
          .addEventListener("click", () => this.closePolygon());
        document
          .getElementById("toggleGridBtn")
          .addEventListener("click", () => this.toggleGrid());
        document
          .getElementById("toggleDimensionsBtn")
          .addEventListener("click", () => this.toggleDimensions());
        document
          .getElementById("zoomFitBtn")
          .addEventListener("click", () => this.zoomToFit());
        document
          .getElementById("centerViewBtn")
          .addEventListener("click", () => this.centerView());
        document
          .getElementById("exportDxfBtn")
          .addEventListener("click", () => this.exportDXF());
      }
      createNewPolygon() {
        const newPolygon = {
          id: Date.now(),
          name: `Polígono ${this.polygons.length + 1}`,
          points: [],
          color: this.getRandomColor(),
          closed: false,
        };
        this.polygons.push(newPolygon);
        this.activePolygonIndex = this.polygons.length - 1;
        this.updatePolygonList();
        this.updateInfo();
      }
      deleteActivePolygon() {
        if (this.activePolygonIndex >= 0) {
          const polygon = this.polygons[this.activePolygonIndex];
          // Si tiene hijos, preguntar confirmación
          const children = this.polygonHierarchy.get(polygon.id) || [];
          if (children.length > 0) {
            if (!confirm(`Este polígono tiene ${children.length} polígonos hijos. ¿Desea eliminar todo el grupo?`)) {
              return;
            }
            // Eliminar todos los polígonos hijos
            children.forEach(childId => {
              const childIndex = this.polygons.findIndex(p => p.id === childId);
              if (childIndex >= 0) {
                this.polygons.splice(childIndex, 1);
                // Ajustar activePolygonIndex si es necesario
                if (childIndex < this.activePolygonIndex) {
                  this.activePolygonIndex--;
                }
              }
              this.polygonDivisions.delete(childId);
              this.polygonParents.delete(childId);
            });
            this.polygonHierarchy.delete(polygon.id);
          }
          // Si es un polígono hijo, actualizar la jerarquía del padre
          if (this.polygonParents.has(polygon.id)) {
            const parentId = this.polygonParents.get(polygon.id);
            const siblings = this.polygonHierarchy.get(parentId) || [];
            const siblingIndex = siblings.indexOf(polygon.id);
            if (siblingIndex >= 0) {
              siblings.splice(siblingIndex, 1);
              this.polygonHierarchy.set(parentId, siblings);
            }
            this.polygonParents.delete(polygon.id);
          }
          // Eliminar divisiones del polígono
          this.polygonDivisions.delete(polygon.id);
          // Eliminar el polígono
          this.polygons.splice(this.activePolygonIndex, 1);
          this.activePolygonIndex = this.polygons.length > 0 ? Math.max(0, this.activePolygonIndex - 1) : -1;
          if (this.polygons.length === 0) {
            this.createNewPolygon();
          }
          this.updatePolygonList();
          this.updateInfo();
          this.updateResults(this.getCurrentDivisions());
          this.showStatus("Polígono eliminado", "success");
        }
      }
      setActivePolygon(index) {
        this.activePolygonIndex = index;

        // Actualizar lista de polígonos
        this.updatePolygonList();

        // Actualizar información del polígono activo
        this.updateInfo();

        // Asegurarnos de que el polígono activo tenga una entrada en polygonDivisions
        const activePolygon = this.getActivePolygon();
        if (activePolygon && !this.polygonDivisions.has(activePolygon.id)) {
          this.polygonDivisions.set(activePolygon.id, []);
        }

        // Obtener divisiones del polígono activo
        const divisions = this.getCurrentDivisions();

        // IMPORTANTE: Actualizar resultados con las divisiones del polígono activo
        this.updateResults(divisions);

        // IMPORTANTE: Forzar redibujado completo del canvas
        this.draw();

        // Debug: Mostrar en consola las divisiones del polígono activo
        console.log(`Polígono activo: ${activePolygon ? activePolygon.name : 'Ninguno'}`);
        console.log(`Divisiones: ${divisions.length} lotes`);
      }
      getActivePolygon() {
        return this.activePolygonIndex >= 0
          ? this.polygons[this.activePolygonIndex]
          : null;
      }
      getCurrentDivisions() {
        const activePolygon = this.getActivePolygon();
        return activePolygon
          ? this.polygonDivisions.get(activePolygon.id) || []
          : [];
      }
      // Nueva función para manejar la importación (texto o archivo)
      handleImport() {
        const coordinatesText = document
          .getElementById("coordinatesInput")
          .value.trim();
        const fileInput = document.getElementById("fileInput");
        if (coordinatesText) {
          this.importCoordinates(coordinatesText);
        } else if (fileInput.files.length > 0) {
          const file = fileInput.files[0];
          this.importFromFile(file);
        } else {
          this.showStatus(
            "Por favor ingrese coordenadas o seleccione un archivo",
            "warning"
          );
        }
      }
      // Nueva función para importar desde archivo
      importFromFile(file) {
        const fileName = file.name.toLowerCase();
        const reader = new FileReader();
        reader.onload = (e) => {
          const content = e.target.result;
          if (fileName.endsWith(".txt")) {
            this.importFromTXT(content);
          } else if (fileName.endsWith(".dxf")) {
            this.importFromDXF(content);
          } else {
            this.showStatus("Formato de archivo no soportado", "error");
          }
        };
        reader.onerror = () => {
          this.showStatus("Error al leer el archivo", "error");
        };
        reader.readAsText(file);
      }
      importCoordinates() {
        const coordinatesText = document
          .getElementById("coordinatesInput")
          .value.trim();
        if (!coordinatesText) {
          this.showStatus("Por favor ingrese coordenadas", "warning");
          return;
        }
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;
        try {
          const lines = coordinatesText.split("\n");
          const newPoints = [];
          for (let line of lines) {
            line = line.trim();
            if (!line) continue;
            // Soportar diferentes separadores
            const coords = line.split(/[,;\s]+/);
            if (coords.length >= 2) {
              const x = parseFloat(coords[0]);
              const y = parseFloat(coords[1]);
              if (!isNaN(x) && !isNaN(y)) {
                newPoints.push({ x, y });
              }
            }
          }
          if (newPoints.length === 0) {
            this.showStatus(
              "No se pudieron leer coordenadas válidas",
              "error"
            );
            return;
          }
          // Reemplazar puntos existentes con los nuevos
          activePolygon.points = newPoints;
          activePolygon.closed = newPoints.length >= 3;
          // Limpiar el campo de entrada
          document.getElementById("coordinatesInput").value = "";
          // Ajustar vista automáticamente
          setTimeout(() => this.zoomToFit(), 100);
          this.updateInfo();
          this.showStatus(
            `${newPoints.length} puntos importados exitosamente`,
            "success"
          );
        } catch (error) {
          this.showStatus(
            "Error al procesar coordenadas: " + error.message,
            "error"
          );
        }
      }
      // Nueva función para importar desde archivo TXT
      importFromTXT(content) {
        // Asumimos que el archivo TXT tiene el mismo formato que el textarea (X,Y por línea)
        this.importCoordinates(content);
      }
      // Nueva función para importar desde archivo DXF
      importFromDXF(content) {
        try {
          const polygons = [];
          const lines = content.split('\n').map(line => line.trim());
          let i = 0;
          let inEntitiesSection = false;

          // Buscar la sección ENTITIES
          while (i < lines.length) {
            if (lines[i] === '2' && lines[i + 1] === 'ENTITIES') {
              inEntitiesSection = true;
              i += 2;
              break;
            }
            i++;
          }

          if (!inEntitiesSection) {
            this.showStatus("No se encontró la sección ENTITIES en el archivo DXF", "error");
            return;
          }

          // Procesar entidades hasta encontrar el final de la sección
          while (i < lines.length) {
            // Verificar si hemos llegado al final de la sección ENTITIES
            if (lines[i] === '0' && lines[i + 1] === 'ENDSEC') {
              break;
            }

            // Buscar el inicio de una entidad
            if (lines[i] === '0') {
              const entityType = lines[i + 1];

              // Procesar solo las entidades que nos interesan
              if (['POLYLINE', 'LWPOLYLINE', 'ARC', 'CIRCLE', 'ELLIPSE', 'SPLINE', 'LINE'].includes(entityType)) {
                const entity = this.parseEntity(lines, i);
                if (entity && entity.points && entity.points.length > 0) {
                  // Para polilíneas con arcos, asegurarse de que estén cerradas si es necesario
                  if (entity.curveData && (entity.curveData.type === 'lwpolyline_with_arcs' || entity.curveData.type === 'polyline_with_arcs')) {
                    // Si la polilínea está marcada como cerrada, asegurarse de que el primer y último punto coincidan
                    if (entity.curveData.isClosed && entity.points.length > 1) {
                      const firstPoint = entity.points[0];
                      const lastPoint = entity.points[entity.points.length - 1];
                      const dx = firstPoint.x - lastPoint.x;
                      const dy = firstPoint.y - lastPoint.y;
                      const distance = Math.sqrt(dx * dx + dy * dy);

                      // Si el primer y último punto no son muy cercanos, agregar el primer punto al final
                      if (distance > 1e-6) {
                        entity.points.push({ ...firstPoint });
                      }
                    }
                  }

                  // Eliminar puntos duplicados consecutivos
                  const cleanedPoints = this.removeConsecutiveDuplicates(entity.points);

                  // Validar que el polígono importado sea válido
                  if (cleanedPoints.length >= 3 && this.isValidPolygon(cleanedPoints)) {
                    polygons.push(cleanedPoints);
                    // Guardar datos de curva si existen
                    if (entity.curveData) {
                      this.curveData.set(polygons.length - 1, entity.curveData);
                    }
                  }
                }
                i = entity.nextIndex;
              } else {
                // Saltar esta entidad
                i += 2;
                // Avanzar hasta encontrar el inicio de la siguiente entidad
                while (i < lines.length && !(lines[i] === '0' && (lines[i + 1] === 'ENDSEC' || this.isEntityType(lines[i + 1])))) {
                  i += 2;
                }
              }
            } else {
              i++;
            }
          }

          if (polygons.length === 0) {
            this.showStatus("No se encontraron entidades válidas en el archivo DXF", "error");
            return;
          }

          // Limpiar polígonos existentes
          this.polygons = [];
          this.activePolygonIndex = -1;

          // Crear nuevos polígonos
          polygons.forEach((points, index) => {
            if (points.length >= 3) { // Solo permitir polígonos con 3+ puntos
              const newPolygon = {
                id: Date.now() + index,
                name: `Polígono ${this.polygons.length + 1}`,
                points: points,
                color: this.getRandomColor(),
                closed: true, // Asegurar que todos los polígonos importados estén cerrados
              };
              this.polygons.push(newPolygon);
            }
          });

          if (this.polygons.length === 0) {
            this.showStatus("No se encontraron entidades con suficientes puntos", "error");
            return;
          }

          this.activePolygonIndex = 0;
          document.getElementById("coordinatesInput").value = "";
          document.getElementById("fileInput").value = "";
          setTimeout(() => this.zoomToFit(), 100);
          this.updatePolygonList();
          this.updateInfo();

          const curveCount = Array.from(this.curveData.keys()).length;
          const statusMessage = curveCount > 0
            ? `${polygons.length} entidades importadas (${curveCount} con curvas interpoladas)`
            : `${polygons.length} entidades importadas desde DXF`;
          this.showStatus(statusMessage, "success");
        } catch (error) {
          console.error("Error en importFromDXF:", error);
          this.showStatus("Error al procesar archivo DXF: " + error.message, "error");
        }
      }

      // Función auxiliar para eliminar puntos duplicados consecutivos
      removeConsecutiveDuplicates(points) {
        if (points.length <= 1) return points;

        const cleanedPoints = [points[0]];

        for (let i = 1; i < points.length; i++) {
          const prevPoint = cleanedPoints[cleanedPoints.length - 1];
          const currentPoint = points[i];

          const dx = prevPoint.x - currentPoint.x;
          const dy = prevPoint.y - currentPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Solo agregar el punto si está a una distancia significativa del anterior
          if (distance > 1e-6) {
            cleanedPoints.push(currentPoint);
          }
        }

        // Verificar si el primer y último punto son muy cercanos (polígonos cerrados)
        if (cleanedPoints.length > 2) {
          const firstPoint = cleanedPoints[0];
          const lastPoint = cleanedPoints[cleanedPoints.length - 1];
          const dx = firstPoint.x - lastPoint.x;
          const dy = firstPoint.y - lastPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Si el primer y último punto son muy cercanos, eliminar el último
          if (distance <= 1e-6) {
            cleanedPoints.pop();
          }
        }

        return cleanedPoints;
      }

      // Función auxiliar para verificar si un string es un tipo de entidad
      isEntityType(str) {
        return ['POLYLINE', 'LWPOLYLINE', 'ARC', 'CIRCLE', 'ELLIPSE', 'SPLINE', 'LINE'].includes(str);
      }
      // ============================================================================
      // 3. AGREGAR NUEVAS FUNCIONES PARA PARSEO DE ENTIDADES DXF CON CURVAS
      // ============================================================================
      parseEntity(lines, startIndex) {
        let i = startIndex;

        // Verificar que estamos en el inicio de una entidad
        if (lines[i] !== '0') {
          return null;
        }

        const entityType = lines[i + 1];
        i += 2;

        switch (entityType) {
          case 'POLYLINE':
            return this.parsePolyline(lines, i);
          case 'LWPOLYLINE':
            return this.parseLWPolyline(lines, i);
          case 'ARC':
            return this.parseArc(lines, i);
          case 'CIRCLE':
            return this.parseCircle(lines, i);
          case 'ELLIPSE':
            return this.parseEllipse(lines, i);
          case 'SPLINE':
            return this.parseSpline(lines, i);
          case 'LINE':
            return this.parseLine(lines, i);
          default:
            // Para otras entidades, avanzar hasta el inicio de la siguiente entidad
            while (i < lines.length && !(lines[i] === '0' && (lines[i + 1] === 'ENDSEC' || this.isEntityType(lines[i + 1])))) {
              i += 2;
            }
            return { nextIndex: i };
        }
      }
      parsePolyline(lines, startIndex) {
        const points = [];
        const bulges = [];
        let i = startIndex;
        let isClosed = false;

        // Leer flags de la polilínea
        while (i < lines.length) {
          if (lines[i] === '0' && lines[i + 1] === 'VERTEX') {
            break; // Empezamos los vértices
          }
          if (lines[i] === '70') {
            const flags = parseInt(lines[i + 1]);
            isClosed = (flags & 1) !== 0;
            i += 2;
          } else {
            i += 2;
          }
        }

        // Buscar vértices
        while (i < lines.length) {
          if (lines[i] === '0' && lines[i + 1] === 'SEQEND') {
            i += 2;
            break;
          }
          if (lines[i] === '0' && lines[i + 1] === 'VERTEX') {
            i += 2;
            let x = null, y = null, bulge = 0;

            while (i < lines.length && !(lines[i] === '0' && (lines[i + 1] === 'VERTEX' || lines[i + 1] === 'SEQEND'))) {
              switch (lines[i]) {
                case '10':
                  x = parseFloat(lines[i + 1]);
                  i += 2;
                  break;
                case '20':
                  y = parseFloat(lines[i + 1]);
                  i += 2;
                  break;
                case '42':
                  bulge = parseFloat(lines[i + 1]);
                  i += 2;
                  break;
                default:
                  i += 2;
              }
            }

            if (x !== null && y !== null) {
              points.push({ x, y });
              bulges.push(bulge);
            }
          } else {
            i += 2;
          }
        }

        // Si la polilínea está cerrada, verificar si el último punto ya es igual al primero
        if (isClosed && points.length > 1) {
          const firstPoint = points[0];
          const lastPoint = points[points.length - 1];
          const dx = firstPoint.x - lastPoint.x;
          const dy = firstPoint.y - lastPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Solo agregar el primer punto al final si el último no es suficientemente cercano
          if (distance > 1e-6) {
            points.push({ ...firstPoint });
            bulges.push(0);
          }
        }

        // Procesar bulges para crear arcos
        const finalPoints = [];
        for (let j = 0; j < points.length - 1; j++) {
          finalPoints.push(points[j]);
          if (Math.abs(bulges[j]) > 1e-10) {
            const nextPoint = points[j + 1];
            const arcPoints = this.createArcFromBulge(points[j], nextPoint, bulges[j]);
            // Agregamos los puntos del arco (excepto el último que es el siguiente punto)
            finalPoints.push(...arcPoints.slice(0, -1));
          }
        }

        // Agregar el último punto solo si no es igual al primero
        if (points.length > 0) {
          const lastPoint = points[points.length - 1];
          const firstPoint = points[0];
          const dx = firstPoint.x - lastPoint.x;
          const dy = firstPoint.y - lastPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 1e-6 || !isClosed) {
            finalPoints.push(lastPoint);
          }
        }

        return {
          points: finalPoints,
          nextIndex: i,
          curveData: points.length > 2 ? {
            type: 'polyline_with_arcs',
            bulges,
            isClosed
          } : null
        };
      }
      parseLWPolyline(lines, startIndex) {
        const points = [];
        const bulges = [];
        let i = startIndex;
        let isClosed = false;

        while (i < lines.length) {
          if (lines[i] === '0') {
            // Fin de la entidad
            break;
          }

          const groupCode = lines[i];
          const value = lines[i + 1];

          switch (groupCode) {
            case '10': // Coordenada X
              const x = parseFloat(value);
              i += 2;
              if (i < lines.length && lines[i] === '20') {
                const y = parseFloat(lines[i + 1]);
                points.push({ x, y });
                i += 2;
                // Buscar bulge para este vértice
                if (i < lines.length && lines[i] === '42') {
                  bulges.push(parseFloat(lines[i + 1]));
                  i += 2;
                } else {
                  bulges.push(0);
                }
              }
              break;
            case '70': // Flags de polilínea
              const flags = parseInt(value);
              isClosed = (flags & 1) !== 0;
              i += 2;
              break;
            default:
              i += 2;
          }
        }

        // Si la polilínea está cerrada, verificar si el último punto ya es igual al primero
        if (isClosed && points.length > 1) {
          const firstPoint = points[0];
          const lastPoint = points[points.length - 1];
          const dx = firstPoint.x - lastPoint.x;
          const dy = firstPoint.y - lastPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Solo agregar el primer punto al final si el último no es suficientemente cercano
          if (distance > 1e-6) {
            points.push({ ...firstPoint });
            bulges.push(0);
          }
        }

        // Procesar puntos y bulges para crear arcos donde sea necesario
        const finalPoints = [];
        for (let j = 0; j < points.length - 1; j++) {
          // Agregar el punto actual
          finalPoints.push(points[j]);

          // Si hay un bulge no nulo para este vértice
          if (Math.abs(bulges[j]) > 1e-10) {
            const nextPoint = points[j + 1];
            // Creamos el arco entre el punto actual y el siguiente
            const arcPoints = this.createArcFromBulge(points[j], nextPoint, bulges[j]);
            // Agregamos los puntos del arco (excepto el último que es el siguiente punto)
            finalPoints.push(...arcPoints.slice(0, -1));
          }
        }

        // Agregar el último punto solo si no es igual al primero
        if (points.length > 0) {
          const lastPoint = points[points.length - 1];
          const firstPoint = points[0];
          const dx = firstPoint.x - lastPoint.x;
          const dy = firstPoint.y - lastPoint.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 1e-6 || !isClosed) {
            finalPoints.push(lastPoint);
          }
        }

        return {
          points: finalPoints,
          nextIndex: i,
          curveData: bulges.some(b => Math.abs(b) > 1e-10) ? {
            type: 'lwpolyline_with_arcs',
            bulges,
            isClosed
          } : null
        };
      }
      parseArc(lines, startIndex) {
        let i = startIndex + 1;
        let centerX = 0, centerY = 0, radius = 0, startAngle = 0, endAngle = 0;
        while (i < lines.length && lines[i] !== '0') {
          if (lines[i] === '10') centerX = parseFloat(lines[i + 1]);
          else if (lines[i] === '20') centerY = parseFloat(lines[i + 1]);
          else if (lines[i] === '40') radius = parseFloat(lines[i + 1]);
          else if (lines[i] === '50') startAngle = parseFloat(lines[i + 1]) * Math.PI / 180;
          else if (lines[i] === '51') endAngle = parseFloat(lines[i + 1]) * Math.PI / 180;
          i += 2;
        }
        const points = this.createArcPoints(centerX, centerY, radius, startAngle, endAngle);
        return {
          points: points,
          nextIndex: i,
          curveData: { type: 'arc', centerX, centerY, radius, startAngle, endAngle }
        };
      }
      parseCircle(lines, startIndex) {
        let i = startIndex + 1;
        let centerX = 0, centerY = 0, radius = 0;
        while (i < lines.length && lines[i] !== '0') {
          if (lines[i] === '10') centerX = parseFloat(lines[i + 1]);
          else if (lines[i] === '20') centerY = parseFloat(lines[i + 1]);
          else if (lines[i] === '40') radius = parseFloat(lines[i + 1]);
          i += 2;
        }
        const points = this.createCirclePoints(centerX, centerY, radius);
        return {
          points: points,
          nextIndex: i,
          curveData: { type: 'circle', centerX, centerY, radius }
        };
      }
      parseEllipse(lines, startIndex) {
        let i = startIndex + 1;
        let centerX = 0, centerY = 0, majorX = 0, majorY = 0, ratio = 1;
        let startParam = 0, endParam = 2 * Math.PI;
        while (i < lines.length && lines[i] !== '0') {
          if (lines[i] === '10') centerX = parseFloat(lines[i + 1]);
          else if (lines[i] === '20') centerY = parseFloat(lines[i + 1]);
          else if (lines[i] === '11') majorX = parseFloat(lines[i + 1]);
          else if (lines[i] === '21') majorY = parseFloat(lines[i + 1]);
          else if (lines[i] === '40') ratio = parseFloat(lines[i + 1]);
          else if (lines[i] === '41') startParam = parseFloat(lines[i + 1]);
          else if (lines[i] === '42') endParam = parseFloat(lines[i + 1]);
          i += 2;
        }
        const points = this.createEllipsePoints(centerX, centerY, majorX, majorY, ratio, startParam, endParam);
        return {
          points: points,
          nextIndex: i,
          curveData: { type: 'ellipse', centerX, centerY, majorX, majorY, ratio, startParam, endParam }
        };
      }
      parseSpline(lines, startIndex) {
        let i = startIndex + 1;
        const controlPoints = [];
        const fitPoints = [];
        let degree = 3;
        while (i < lines.length && lines[i] !== '0') {
          if (lines[i] === '71') {
            degree = parseInt(lines[i + 1]);
          } else if (lines[i] === '10') {
            const x = parseFloat(lines[i + 1]);
            i += 2;
            if (lines[i] === '20') {
              const y = parseFloat(lines[i + 1]);
              controlPoints.push({ x, y });
            }
          } else if (lines[i] === '11') {
            const x = parseFloat(lines[i + 1]);
            i += 2;
            if (lines[i] === '21') {
              const y = parseFloat(lines[i + 1]);
              fitPoints.push({ x, y });
            }
          }
          i += 2;
        }
        // Usar fit points si están disponibles, sino interpolar control points
        const points = fitPoints.length > 0
          ? this.interpolateSplineFromFitPoints(fitPoints)
          : this.interpolateSplineFromControlPoints(controlPoints, degree);
        return {
          points: points,
          nextIndex: i,
          curveData: { type: 'spline', controlPoints, fitPoints, degree }
        };
      }
      parseLine(lines, startIndex) {
        let i = startIndex + 1;
        let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        while (i < lines.length && lines[i] !== '0') {
          if (lines[i] === '10') x1 = parseFloat(lines[i + 1]);
          else if (lines[i] === '20') y1 = parseFloat(lines[i + 1]);
          else if (lines[i] === '11') x2 = parseFloat(lines[i + 1]);
          else if (lines[i] === '21') y2 = parseFloat(lines[i + 1]);
          i += 2;
        }
        return {
          points: [{ x: x1, y: y1 }, { x: x2, y: y2 }],
          nextIndex: i
        };
      }
      // ============================================================================
      // 4. AGREGAR FUNCIONES MATEMÁTICAS PARA INTERPOLACIÓN DE CURVAS
      // ============================================================================
      createArcFromBulge(startPoint, endPoint, bulge) {
        if (Math.abs(bulge) < 1e-10) {
          return [startPoint, endPoint];
        }

        const dx = endPoint.x - startPoint.x;
        const dy = endPoint.y - startPoint.y;
        const chord = Math.sqrt(dx * dx + dy * dy);

        if (chord < 1e-10) return [startPoint];

        // El bulge es la tangente de un cuarto del ángulo subtendido por el arco
        const angle = 4 * Math.atan(Math.abs(bulge));

        // Calcular el radio
        const radius = chord / (2 * Math.sin(angle / 2));

        // Calcular la sagitta (flecha)
        const sagitta = radius * (1 - Math.cos(angle / 2));

        // Calcular el centro del arco
        const midX = (startPoint.x + endPoint.x) / 2;
        const midY = (startPoint.y + endPoint.y) / 2;

        // Vector perpendicular al segmento
        const perpX = -dy / chord;
        const perpY = dx / chord;

        // La dirección del centro depende del signo del bulge
        const direction = bulge > 0 ? 1 : -1;

        // Distancia desde el punto medio hasta el centro
        const distToCenter = radius - sagitta;

        const centerX = midX + direction * perpX * distToCenter;
        const centerY = midY + direction * perpY * distToCenter;

        // Calcular los ángulos inicial y final
        const startAngle = Math.atan2(startPoint.y - centerY, startPoint.x - centerX);
        const endAngle = Math.atan2(endPoint.y - centerY, endPoint.x - centerX);

        // Determinar si el arco va en sentido horario o antihorario
        const counterClockwise = bulge > 0;

        // Generar los puntos del arco
        return this.createArcPoints(centerX, centerY, radius, startAngle, endAngle, counterClockwise);
      }
      createArcPoints(centerX, centerY, radius, startAngle, endAngle, counterClockwise = true) {
        const points = [];
        let deltaAngle = endAngle - startAngle;

        // Normalizar ángulos
        if (counterClockwise && deltaAngle < 0) {
          deltaAngle += 2 * Math.PI;
        } else if (!counterClockwise && deltaAngle > 0) {
          deltaAngle -= 2 * Math.PI;
        }

        // Asegurar un mínimo de pasos para arcos pequeños
        const steps = Math.max(20, Math.ceil(Math.abs(deltaAngle) * this.curveResolution / (2 * Math.PI)));

        // Generar puntos
        for (let i = 0; i < steps; i++) {
          const angle = startAngle + (deltaAngle * i / steps);
          points.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          });
        }

        // Agregar el punto final solo si es significativamente diferente del último punto generado
        const lastGeneratedPoint = points[points.length - 1];
        const exactEndPoint = {
          x: centerX + radius * Math.cos(endAngle),
          y: centerY + radius * Math.sin(endAngle)
        };

        const dx = exactEndPoint.x - lastGeneratedPoint.x;
        const dy = exactEndPoint.y - lastGeneratedPoint.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Solo agregar el punto exacto si está a una distancia significativa
        if (distance > 1e-6) {
          points.push(exactEndPoint);
        }

        return points;
      }
      createCirclePoints(centerX, centerY, radius) {
        const points = [];
        const steps = this.curveResolution;
        for (let i = 0; i < steps; i++) {
          const angle = (2 * Math.PI * i) / steps;
          points.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle)
          });
        }
        return points;
      }
      createEllipsePoints(centerX, centerY, majorX, majorY, ratio, startParam, endParam) {
        const points = [];
        const majorRadius = Math.sqrt(majorX * majorX + majorY * majorY);
        const minorRadius = majorRadius * ratio;
        const angle = Math.atan2(majorY, majorX);
        let deltaParam = endParam - startParam;
        if (deltaParam < 0) deltaParam += 2 * Math.PI;
        const steps = Math.max(8, Math.ceil(deltaParam * this.curveResolution / (2 * Math.PI)));
        for (let i = 0; i <= steps; i++) {
          const param = startParam + (deltaParam * i / steps);
          const localX = majorRadius * Math.cos(param);
          const localY = minorRadius * Math.sin(param);
          // Rotar y trasladar
          const rotatedX = localX * Math.cos(angle) - localY * Math.sin(angle);
          const rotatedY = localX * Math.sin(angle) + localY * Math.cos(angle);
          points.push({
            x: centerX + rotatedX,
            y: centerY + rotatedY
          });
        }
        return points;
      }
      interpolateSplineFromFitPoints(fitPoints) {
        if (fitPoints.length < 2) return fitPoints;
        const points = [];
        const steps = this.curveResolution;
        for (let i = 0; i < fitPoints.length - 1; i++) {
          const p1 = fitPoints[i];
          const p2 = fitPoints[i + 1];
          // Interpolación lineal simple entre fit points
          for (let j = 0; j < steps; j++) {
            const t = j / steps;
            points.push({
              x: p1.x + t * (p2.x - p1.x),
              y: p1.y + t * (p2.y - p1.y)
            });
          }
        }
        points.push(fitPoints[fitPoints.length - 1]);
        return points;
      }
      interpolateSplineFromControlPoints(controlPoints, degree) {
        if (controlPoints.length < degree + 1) {
          return controlPoints;
        }
        // Implementación simplificada de B-spline
        const points = [];
        const steps = this.curveResolution;
        const n = controlPoints.length - 1;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          let x = 0, y = 0;
          for (let j = 0; j <= n; j++) {
            const basis = this.bernsteinBasis(j, n, t);
            x += basis * controlPoints[j].x;
            y += basis * controlPoints[j].y;
          }
          points.push({ x, y });
        }
        return points;
      }
      bernsteinBasis(i, n, t) {
        return this.binomialCoefficient(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i);
      }
      binomialCoefficient(n, k) {
        if (k > n) return 0;
        if (k === 0 || k === n) return 1;
        let result = 1;
        for (let i = 0; i < k; i++) {
          result = result * (n - i) / (i + 1);
        }
        return result;
      }
      updatePolygonList() {
        const listContainer = document.getElementById("polygonList");
        listContainer.innerHTML = "";

        this.polygons.forEach((polygon, index) => {
          const divisions = this.polygonDivisions.get(polygon.id) || [];
          const children = this.polygonHierarchy.get(polygon.id) || [];
          const isParent = this.polygonParents.has(polygon.id);

          const item = document.createElement("div");
          item.className = `polygon-item ${index === this.activePolygonIndex ? "active" : ""}`;

          // Indentación/ícono según jerarquía
          const indent = isParent ? " ↳ " : "";
          const parentIcon = children.length > 0 ? "📁 " : isParent ? "📄 " : "📐 ";

          // Texto derecho (meta): "5 pts | 2 div | 1 hijos"
          const meta = [
            `${polygon.points.length} pts`,
            divisions.length ? `${divisions.length} div` : null,
            children.length ? `${children.length} hijos` : null,
          ].filter(Boolean).join(" | ");

          // Indicador visual para polígonos con divisiones
          const divisionIndicator = divisions.length > 0 ? ' <span style="color: #4caf50;">●</span>' : '';

          item.innerHTML = `
      <div style="display:flex; align-items:center; justify-content:flex-start; gap:8px;">
        <span style="color:${polygon.color};">●</span>
        <span>${indent}${parentIcon}${polygon.name}${divisionIndicator}</span>
        <small>${meta}</small>
      </div>
    `;

          item.addEventListener("click", () => this.setActivePolygon(index));
          listContainer.appendChild(item);
        });
      }

      getRandomColor() {
        const colors = [
          "#ff9800",
          "#4caf50",
          "#9c27b0",
          "#f44336",
          "#2196f3",
          "#ffeb3b",
          "#795548",
          "#607d8b",
        ];
        return colors[this.polygons.length % colors.length];
      }
      startDrawingAuxiliary() {
        this.isDrawingAuxiliary = true;
        this.isSelectingSegment = false;
        this.selectedSegment = null;
        this.auxiliaryLine = null;
        this.auxiliaryStart = null;
        this.canvas.style.cursor = "crosshair";
        document.getElementById("segmentInfo").style.display = "none";
        this.showStatus(
          "Click dos puntos para definir la línea auxiliar",
          "warning"
        );
      }
      // NUEVA FUNCIÓN - AGREGAR:
      startSelectingSegment() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon || activePolygon.points.length < 2) {
          this.showStatus("Se necesita un polígono válido", "error");
          return;
        }
        this.isSelectingSegment = true;
        this.isDrawingAuxiliary = false;
        this.auxiliaryLine = null;
        this.auxiliaryStart = null;
        this.selectedSegment = null;
        this.canvas.style.cursor = "pointer";
        document.getElementById("segmentInfo").style.display = "block";
        document.getElementById("segmentInfo").textContent =
          "Click en un segmento del polígono activo";
        this.showStatus(
          "Seleccione un segmento del polígono como línea auxiliar",
          "warning"
        );
      }
      clearAuxiliaryLine() {
        this.auxiliaryLine = null;
        this.isDrawingAuxiliary = false;
        this.isSelectingSegment = false;
        this.selectedSegment = null;
        this.hoveredSegment = null;
        this.auxiliaryStart = null;
        this.canvas.style.cursor = "crosshair";
        document.getElementById("segmentInfo").style.display = "none";
        this.showStatus("Línea auxiliar eliminada", "success");
      }
      // === NUEVAS FUNCIONES PARA DIVISIÓN ROTATORIA ===
      startSettingRotationalCenter() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon || activePolygon.points.length < 3) {
          this.showStatus("Se necesita un polígono válido", "error");
          return;
        }
        this.isSettingRotationalCenter = true;
        this.isDrawingAuxiliary = false;
        this.isSelectingSegment = false;
        this.canvas.style.cursor = "crosshair";
        this.showStatus("Click para establecer el punto de rotación", "warning");
        this.updateRotationalCenterInfo();
      }
      clearRotationalCenter() {
        this.rotationalCenter = null;
        this.isSettingRotationalCenter = false;
        this.canvas.style.cursor = "crosshair";
        this.showStatus("Punto de rotación eliminado", "success");
        this.updateRotationalCenterInfo();
      }
      // Interpolación de curvas a puntos lineales
      interpolateCurveToPoints(curvePoints, segments = 50) {
        if (curvePoints.length < 4) return curvePoints;
        const interpolated = [];
        for (let i = 0; i < curvePoints.length - 3; i += 3) {
          const p0 = curvePoints[i];
          const p1 = curvePoints[i + 1];
          const p2 = curvePoints[i + 2];
          const p3 = curvePoints[i + 3];
          for (let t = 0; t <= 1; t += 1 / segments) {
            const point = this.cubicBezierPoint(p0, p1, p2, p3, t);
            interpolated.push(point);
          }
        }
        return interpolated.length > 0 ? interpolated : curvePoints;
      }
      cubicBezierPoint(p0, p1, p2, p3, t) {
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * t;
        return {
          x: uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x,
          y: uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y
        };
      }
      // Algoritmo de recorte por línea rotatoria
      clipPolygonByRotationalLine(polygon, centerPoint, angle, keepClockwise = true) {
        if (polygon.length === 0) return [];
        // Crear línea infinita desde el centro con el ángulo dado
        const lineDir = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };
        const lineStart = {
          x: centerPoint.x - lineDir.x * this.rotationalRadius,
          y: centerPoint.y - lineDir.y * this.rotationalRadius
        };
        const lineEnd = {
          x: centerPoint.x + lineDir.x * this.rotationalRadius,
          y: centerPoint.y + lineDir.y * this.rotationalRadius
        };
        const result = [];
        for (let i = 0; i < polygon.length; i++) {
          const current = polygon[i];
          const next = polygon[(i + 1) % polygon.length];
          const currentSide = this.getPointSideOfLine(current, lineStart, lineEnd);
          const nextSide = this.getPointSideOfLine(next, lineStart, lineEnd);
          const currentInside = keepClockwise ? currentSide >= 0 : currentSide <= 0;
          const nextInside = keepClockwise ? nextSide >= 0 : nextSide <= 0;
          // Si el punto actual está dentro, lo agregamos
          if (currentInside) {
            result.push({ x: current.x, y: current.y });
          }
          // Si hay un cambio de estado entre current y next, hay intersección
          if (currentInside !== nextInside) {
            const intersection = this.lineIntersection(current, next, lineStart, lineEnd);
            if (intersection) {
              // Evitar duplicados
              const lastPoint = result[result.length - 1];
              if (!lastPoint ||
                Math.abs(lastPoint.x - intersection.x) > this.rotationalTolerance ||
                Math.abs(lastPoint.y - intersection.y) > this.rotationalTolerance) {
                result.push(intersection);
              }
            }
          }
        }
        return result;
      }
      getPointSideOfLine(point, lineStart, lineEnd) {
        return (lineEnd.x - lineStart.x) * (point.y - lineStart.y) -
          (lineEnd.y - lineStart.y) * (point.x - lineStart.x);
      }
      // Función principal de división rotatoria
      async findRotationalDivision(targetArea, polygon, centerPoint, tolerance = 0.001, maxIterations = 8000) {
        if (polygon.length < 3) return null;
        const polygonArea = this.calculateArea(polygon);
        if (targetArea >= polygonArea - tolerance) {
          return {
            cutPolygon: [...polygon],
            remainingPolygon: [],
            area: polygonArea,
            angle: 0,
            iterations: 0,
            error: 0
          };
        }
        let minAngle = 0;
        let maxAngle = 2 * Math.PI;
        let iterations = 0;
        let bestResult = null;
        let bestError = Infinity;
        while (iterations < maxIterations && maxAngle - minAngle > this.rotationalTolerance) {
          const midAngle = (minAngle + maxAngle) / 2;
          // Crear las dos partes del polígono
          const clockwisePart = this.clipPolygonByRotationalLine(polygon, centerPoint, midAngle, true);
          const counterClockwisePart = this.clipPolygonByRotationalLine(polygon, centerPoint, midAngle, false);
          if (clockwisePart.length < 3 && counterClockwisePart.length < 3) {
            // Si ninguna parte es válida, ajustar el rango
            if (targetArea < polygonArea / 2) {
              maxAngle = midAngle;
            } else {
              minAngle = midAngle;
            }
            iterations++;
            continue;
          }
          // Determinar cuál parte usar basado en el área objetivo
          let cutPolygon, remainingPolygon;
          const clockwiseArea = clockwisePart.length >= 3 ? this.calculateArea(clockwisePart) : 0;
          const counterClockwiseArea = counterClockwisePart.length >= 3 ? this.calculateArea(counterClockwisePart) : 0;
          // Elegir la parte que esté más cerca del área objetivo
          const clockwiseError = Math.abs(clockwiseArea - targetArea);
          const counterClockwiseError = Math.abs(counterClockwiseArea - targetArea);
          if (clockwiseError < counterClockwiseError && clockwisePart.length >= 3) {
            cutPolygon = clockwisePart;
            remainingPolygon = counterClockwisePart;
          } else if (counterClockwisePart.length >= 3) {
            cutPolygon = counterClockwisePart;
            remainingPolygon = clockwisePart;
          } else {
            // Solo una parte es válida
            if (clockwisePart.length >= 3) {
              cutPolygon = clockwisePart;
              remainingPolygon = counterClockwisePart;
            } else {
              cutPolygon = counterClockwisePart;
              remainingPolygon = clockwisePart;
            }
          }
          const cutArea = this.calculateArea(cutPolygon);
          const error = Math.abs(cutArea - targetArea);
          if (error < bestError) {
            bestError = error;
            bestResult = {
              cutPolygon,
              remainingPolygon,
              area: cutArea,
              angle: midAngle,
              iterations: iterations + 1,
              error: error
            };
          }
          if (error <= tolerance) break;
          // Búsqueda binaria adaptativa
          if (cutArea < targetArea) {
            if (cutPolygon === clockwisePart) {
              maxAngle = midAngle;
            } else {
              minAngle = midAngle;
            }
          } else {
            if (cutPolygon === clockwisePart) {
              minAngle = midAngle;
            } else {
              maxAngle = midAngle;
            }
          }
          iterations++;
          if (iterations % 100 === 0) {
            const progress = Math.min(95, (iterations / maxIterations) * 100);
            this.updateProgress(progress, `Calculando rotación... (${iterations}/${maxIterations})`);
            await this.sleep(1);
          }
        }
        this.totalIterations += iterations;
        return bestResult;
      }

      toggleDimensions() {
        this.showDimensions = !this.showDimensions;
        document.getElementById("toggleDimensionsBtn").textContent = this
          .showDimensions
          ? "📏 Ocultar Dimensiones"
          : "📏 Mostrar Dimensiones";
      }
      centerView() {
        this.scale = 1;
        this.offsetX = this.canvas.width / 2;
        this.offsetY = this.canvas.height / 2;
      }
      getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: (e.clientX - rect.left - this.offsetX) / this.scale,
          y: (e.clientY - rect.top - this.offsetY) / this.scale,
        };
      }
      handleClick(e) {
        if (this.isDragging || this.isDraggingCanvas) return;
        const rawPos = this.getMousePos(e);
        // === APLICAR SISTEMA DE SNAP ===
        const snapResult = this.snapEnabled ? this.findSnapPoint(rawPos.x, rawPos.y) : null;
        const pos = snapResult ? snapResult.point : rawPos;
        // === NUEVO: MANEJO DEL PUNTO DE ROTACIÓN ===
        if (this.isSettingRotationalCenter) {
          this.rotationalCenter = { x: pos.x, y: pos.y };
          this.isSettingRotationalCenter = false;
          this.canvas.style.cursor = "crosshair";
          const snapInfo = snapResult ? ` (${snapResult.type})` : '';
          this.showStatus(`Punto de rotación establecido${snapInfo}`, "success");
          return;
        }
        if (this.isDrawingAuxiliary) {
          if (!this.auxiliaryStart) {
            this.auxiliaryStart = { x: pos.x, y: pos.y };
            this.showStatus("Click el segundo punto de la línea auxiliar", "warning");
          } else {
            this.auxiliaryLine = {
              start: this.auxiliaryStart,
              end: { x: pos.x, y: pos.y },
            };
            this.isDrawingAuxiliary = false;
            this.auxiliaryStart = null;
            this.canvas.style.cursor = "crosshair";
            // Mostrar tipo de snap utilizado
            const snapInfo = snapResult ? ` (${snapResult.type})` : '';
            this.showStatus(`Línea auxiliar creada${snapInfo}`, "success");
          }
          return;
        }
        if (this.isSelectingSegment) {
          const activePolygon = this.getActivePolygon();
          if (activePolygon && activePolygon.points.length >= 2) {
            const segmentIndex = this.findNearestSegment(activePolygon.points, pos.x, pos.y);
            if (segmentIndex !== -1) {
              const startPoint = activePolygon.points[segmentIndex];
              const endPoint = activePolygon.points[(segmentIndex + 1) % activePolygon.points.length];
              this.auxiliaryLine = {
                start: { x: startPoint.x, y: startPoint.y },
                end: { x: endPoint.x, y: endPoint.y },
              };
              this.selectedSegment = segmentIndex;
              this.isSelectingSegment = false;
              this.canvas.style.cursor = "crosshair";
              document.getElementById("segmentInfo").style.display = "none";
              this.showStatus(`Segmento ${segmentIndex + 1} seleccionado como línea auxiliar`, "success");
            } else {
              this.showStatus("Click más cerca de un segmento del polígono", "warning");
            }
          }
          return;
        }
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;
        // === MODIFICACIÓN: No agregar puntos si el polígono está cerrado ===
        if (activePolygon.closed) {
          this.showStatus("El polígono está cerrado. Seleccione otro polígono o cree uno nuevo.", "warning");
          return;
        }
        // Verificar si está cerca de un punto existente para evitar duplicados
        const nearPoint = this.findNearestPoint(activePolygon.points, pos.x, pos.y);
        if (nearPoint.distance < 10 / this.scale) {
          return;
        }
        // Agregar punto con snap
        this.addPoint(pos.x, pos.y);
        // Mostrar información del snap utilizado
        if (snapResult) {
          this.showSnapIndicator(snapResult.type, e.clientX, e.clientY);
        }
      }
      handleRightClick(e) {
        e.preventDefault();
        if (!this.isDrawingAuxiliary) {
          this.closePolygon();
        }
      }
      handleMouseDown(e) {
        const pos = this.getMousePos(e);
        this.lastMousePos = { x: e.clientX, y: e.clientY };
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
          this.isDraggingCanvas = true;
          this.canvas.style.cursor = "grabbing";
          return;
        }
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;
        const nearPoint = this.findNearestPoint(
          activePolygon.points,
          pos.x,
          pos.y
        );
        if (nearPoint.distance < 10 / this.scale) {
          this.isDragging = true;
          this.dragIndex = nearPoint.index;
          this.canvas.style.cursor = "grabbing";
        }
      }
      handleMouseMove(e) {
        const pos = this.getMousePos(e);
        if (this.isDraggingCanvas) {
          const deltaX = e.clientX - this.lastMousePos.x;
          const deltaY = e.clientY - this.lastMousePos.y;
          this.offsetX += deltaX;
          this.offsetY += deltaY;
          this.lastMousePos = { x: e.clientX, y: e.clientY };
          return;
        }
        if (this.isDragging && this.dragIndex >= 0) {
          const activePolygon = this.getActivePolygon();
          if (activePolygon) {
            // === APLICAR SNAP AL ARRASTRAR ===
            const snapResult = this.snapEnabled ? this.findSnapPoint(pos.x, pos.y) : null;
            const finalPos = snapResult ? snapResult.point : pos;
            activePolygon.points[this.dragIndex] = { x: finalPos.x, y: finalPos.y };
            this.updateInfo();
            // Actualizar cursor y preview
            if (snapResult) {
              this.canvas.className = `snap-cursor ${snapResult.type}`;
              this.currentSnapPoint = snapResult;
            } else {
              this.canvas.className = 'snap-cursor';
              this.currentSnapPoint = null;
            }
          }
          return;
        }
        // === SISTEMA DE SNAP DURANTE MOVIMIENTO ===
        if (this.snapEnabled) {
          const snapResult = this.findSnapPoint(pos.x, pos.y);
          if (snapResult) {
            this.currentSnapPoint = snapResult;
            this.canvas.className = `snap-cursor ${snapResult.type}`;
            // Actualizar línea de preview si estamos dibujando
            this.updatePreviewLine(snapResult.point);
          } else {
            this.currentSnapPoint = null;
            this.canvas.className = 'snap-cursor';
            this.updatePreviewLine(pos);
          }
        } else {
          this.updatePreviewLine(pos);
        }
        if (this.isSelectingSegment) {
          const activePolygon = this.getActivePolygon();
          if (activePolygon && activePolygon.points.length >= 2) {
            const segmentIndex = this.findNearestSegment(activePolygon.points, pos.x, pos.y);
            this.hoveredSegment = segmentIndex !== -1 ? segmentIndex : null;
            if (this.hoveredSegment !== null) {
              this.canvas.style.cursor = "pointer";
              document.getElementById("segmentInfo").textContent =
                `Segmento ${this.hoveredSegment + 1} - Click para seleccionar`;
            } else {
              this.canvas.style.cursor = "default";
              document.getElementById("segmentInfo").textContent =
                "Click en un segmento del polígono activo";
            }
          }
          return;
        }
        const activePolygon = this.getActivePolygon();
        if (activePolygon && !activePolygon.closed) { // Solo mostrar si el polígono no está cerrado
          if (this.snapEnabled) {
            const snapResult = this.findSnapPoint(pos.x, pos.y);
            if (snapResult) {
              this.currentSnapPoint = snapResult;
              this.canvas.className = `snap-cursor ${snapResult.type}`;
              this.updatePreviewLine(snapResult.point);
            } else {
              this.currentSnapPoint = null;
              this.canvas.className = 'snap-cursor';
              this.updatePreviewLine(pos);
            }
          } else {
            this.updatePreviewLine(pos);
          }
        } else {
          this.previewLine = null; // Limpiar la línea si el polígono está cerrado
        }
      }
      findNearestSegment(points, x, y) {
        if (points.length < 2) return -1;
        let minDistance = Infinity;
        let nearestIndex = -1;
        const threshold = 15 / this.scale; // Tolerancia para selección
        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          // Calcular distancia punto-línea
          const distance = this.distancePointToSegment(
            x,
            y,
            p1.x,
            p1.y,
            p2.x,
            p2.y
          );
          if (distance < threshold && distance < minDistance) {
            minDistance = distance;
            nearestIndex = i;
          }
        }
        return nearestIndex;
      }
      // 7. NUEVA FUNCIÓN - AGREGAR:
      distancePointToSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0) {
          // El segmento es un punto
          return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
        }
        const t = Math.max(
          0,
          Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy))
        );
        const projX = x1 + t * dx;
        const projY = y1 + t * dy;
        return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
      }
      handleMouseUp() {
        this.isDragging = false;
        this.isDraggingCanvas = false;
        this.dragIndex = -1;
        this.canvas.style.cursor = "crosshair";
      }
      // FUNCIÓN DE ZOOM MEJORADA
      handleWheel(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        // Posición del mouse en coordenadas del mundo (antes del zoom)
        const worldX = (mouseX - this.offsetX) / this.scale;
        const worldY = (mouseY - this.offsetY) / this.scale;
        // Factor de zoom más suave y progresivo
        let zoomFactor;
        if (e.deltaY < 0) {
          // Zoom in - más agresivo para acercarse rápido
          zoomFactor = this.scale < 0.5 ? 1.3 : this.scale < 2 ? 1.2 : 1.15;
        } else {
          // Zoom out - más suave para mejor control
          zoomFactor = this.scale > 2 ? 0.85 : this.scale > 0.5 ? 0.9 : 0.95;
        }
        const newScale = this.scale * zoomFactor;
        // Límites de zoom más amplios
        this.scale = Math.max(0.05, Math.min(50, newScale));
        // Mantener el punto del mouse fijo durante el zoom
        this.offsetX = mouseX - worldX * this.scale;
        this.offsetY = mouseY - worldY * this.scale;
      }
      addPoint(x, y) {
        const activePolygon = this.getActivePolygon();
        if (activePolygon) {
          activePolygon.points.push({ x, y });
          this.updateInfo();
          this.showStatus("Punto agregado", "success");
        }
      }
      closePolygon() {
        const activePolygon = this.getActivePolygon();
        if (activePolygon && activePolygon.points.length >= 3) {
          activePolygon.closed = true;
          this.updateInfo();
          this.showStatus("Polígono cerrado", "success");
        } else {
          this.showStatus("Se necesitan al menos 3 puntos", "warning");
        }
      }
      undoLastPoint() {
        const activePolygon = this.getActivePolygon();
        if (activePolygon && activePolygon.points.length > 0) {
          activePolygon.points.pop();
          activePolygon.closed = false;
          this.updateInfo();
          this.showStatus("Punto eliminado", "success");
        }
      }
      clearAll() {
        const activePolygon = this.getActivePolygon();
        if (activePolygon) {
          activePolygon.points = [];
          activePolygon.closed = false;
          // Limpiar divisiones del polígono activo
          this.polygonDivisions.delete(activePolygon.id);
        }
        this.auxiliaryLine = null;
        this.updateInfo();
        this.updateResults([]);
        this.showStatus("Polígono limpiado", "success");

        // === NUEVAS PROPIEDADES PARA DIVISIÓN ROTATORIA ===
        this.rotationalCenter = null;
        this.isSettingRotationalCenter = false;
        this.rotationalRadius = 1000; // Radio de la línea de corte
        this.maxRotationalIterations = 8000;
        this.rotationalTolerance = 1e-10;
        this.rotationalConvergence = 0.001;
      }
      toggleGrid() {
        this.showGrid = !this.showGrid;
        document.getElementById("toggleGridBtn").textContent = this.showGrid
          ? "📐 Ocultar Grid"
          : "📐 Mostrar Grid";
      }
      zoomToFit() {
        const allPoints = this.getAllPoints();
        if (allPoints.length === 0) return;
        const bounds = this.getBounds(allPoints);
        const padding = 50;
        const scaleX =
          (this.canvas.width - padding * 2) / (bounds.maxX - bounds.minX);
        const scaleY =
          (this.canvas.height - padding * 2) / (bounds.maxY - bounds.minY);
        this.scale = Math.min(scaleX, scaleY, 2);
        this.offsetX = padding - bounds.minX * this.scale;
        this.offsetY = padding - bounds.minY * this.scale;
      }
      getAllPoints() {
        let allPoints = [];
        this.polygons.forEach((polygon) => {
          allPoints = allPoints.concat(polygon.points);
        });
        return allPoints;
      }
      updateUI() {
        const method = document.getElementById("divisionMethod").value;
        const axis = document.getElementById("divisionAxis").value;
        const numPartsGroup = document.getElementById("numPartsGroup");
        const specificAreaGroup = document.getElementById("specificAreaGroup");
        const auxiliaryControls = document.getElementById("auxiliaryLineControls");
        const rotationalControls = document.getElementById("rotationalControls");
        if (method === "specific") {
          numPartsGroup.style.display = "none";
          specificAreaGroup.style.display = "block";
        } else {
          numPartsGroup.style.display = "block";
          specificAreaGroup.style.display = "none";
        }
        if (axis === "auxiliary") {
          auxiliaryControls.style.display = "block";
          rotationalControls.style.display = "none";
        } else if (axis === "rotational") {
          auxiliaryControls.style.display = "none";
          rotationalControls.style.display = "block";
        } else {
          auxiliaryControls.style.display = "none";
          rotationalControls.style.display = "none";
        }
      }
      updateInfo() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) {
          document.getElementById("pointCount").textContent = "0";
          document.getElementById("totalArea").textContent = "0.00 m²";
          document.getElementById("totalPerimeter").textContent = "0.00 m";
          document.getElementById("isValid").textContent = "-";
          return;
        }
        document.getElementById("pointCount").textContent =
          activePolygon.points.length;
        if (activePolygon.points.length >= 3) {
          const area = this.calculateArea(activePolygon.points);
          const perimeter = this.calculatePerimeter(activePolygon.points);
          const isValid = this.isValidPolygon(activePolygon.points);
          document.getElementById("totalArea").textContent =
            area.toFixed(6) + " m²";
          document.getElementById("totalPerimeter").textContent =
            perimeter.toFixed(6) + " m";
          document.getElementById("isValid").textContent = isValid
            ? "✅ Sí"
            : "❌ No";
        } else {
          document.getElementById("totalArea").textContent = "0.000 m²";
          document.getElementById("totalPerimeter").textContent = "0.000 m";
          document.getElementById("isValid").textContent = "-";
        }
        this.updatePolygonList();
      }
      // Mathematical functions
      calculateArea(pts) {
        if (pts.length < 3) return 0;
        let area = 0;
        const n = pts.length;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          area += (pts[i].x + pts[j].x) * (pts[i].y - pts[j].y);
        }
        return Math.abs(area) / 2;
      }
      calculatePerimeter(pts) {
        if (pts.length < 2) return 0;
        let perimeter = 0;
        for (let i = 0; i < pts.length; i++) {
          const j = (i + 1) % pts.length;
          const dx = pts[j].x - pts[i].x;
          const dy = pts[j].y - pts[i].y;
          perimeter += Math.sqrt(dx * dx + dy * dy);
        }
        return perimeter;
      }
      getCentroid(pts) {
        if (pts.length === 0) return { x: 0, y: 0 };
        const area = this.calculateArea(pts);
        if (area === 0) {
          let x = 0,
            y = 0;
          for (let point of pts) {
            x += point.x;
            y += point.y;
          }
          return { x: x / pts.length, y: y / pts.length };
        }
        let cx = 0,
          cy = 0;
        const n = pts.length;
        for (let i = 0; i < n; i++) {
          const j = (i + 1) % n;
          const cross = pts[i].x * pts[j].y - pts[j].x * pts[i].y;
          cx += (pts[i].x + pts[j].x) * cross;
          cy += (pts[i].y + pts[j].y) * cross;
        }
        const factor = 1 / (6 * area);
        return { x: cx * factor, y: cy * factor };
      }
      getBounds(pts) {
        if (pts.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
        let minX = pts[0].x,
          maxX = pts[0].x;
        let minY = pts[0].y,
          maxY = pts[0].y;
        for (let point of pts) {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        }
        return { minX, maxX, minY, maxY };
      }
      findNearestPoint(points, x, y) {
        let minDistance = Infinity;
        let nearestIndex = 0;
        for (let i = 0; i < points.length; i++) {
          const dx = points[i].x - x;
          const dy = points[i].y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < minDistance) {
            minDistance = distance;
            nearestIndex = i;
          }
        }
        return { index: nearestIndex, distance: minDistance };
      }
      lineIntersection(p1, p2, p3, p4) {
        const x1 = p1.x,
          y1 = p1.y;
        const x2 = p2.x,
          y2 = p2.y;
        const x3 = p3.x,
          y3 = p3.y;
        const x4 = p4.x,
          y4 = p4.y;
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return null;
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
          return {
            x: x1 + t * (x2 - x1),
            y: y1 + t * (y2 - y1),
          };
        }
        return null;
      }
      isValidPolygon(pts) {
        if (pts.length < 3) return false;

        // Verificar que el polígono tenga un área significativa
        const area = this.calculateArea(pts);
        if (area < 1e-5) {
          return false;
        }

        // Verificar intersecciones (simplificado para rendimiento)
        for (let i = 0; i < pts.length; i++) {
          const p1 = pts[i];
          const p2 = pts[(i + 1) % pts.length];

          for (let j = i + 2; j < pts.length; j++) {
            const p3 = pts[j];
            const p4 = pts[(j + 1) % pts.length];

            // Saltar segmentos adyacentes
            if (i === 0 && j === pts.length - 1) continue;

            const intersection = this.lineIntersection(p1, p2, p3, p4);
            if (intersection) {
              // Verificar si la intersección es un vértice (lo cual es válido)
              const isVertex = (
                (Math.abs(intersection.x - p1.x) < 1e-5 && Math.abs(intersection.y - p1.y) < 1e-5) ||
                (Math.abs(intersection.x - p2.x) < 1e-5 && Math.abs(intersection.y - p2.y) < 1e-5) ||
                (Math.abs(intersection.x - p3.x) < 1e-5 && Math.abs(intersection.y - p3.y) < 1e-5) ||
                (Math.abs(intersection.x - p4.x) < 1e-5 && Math.abs(intersection.y - p4.y) < 1e-5)
              );

              if (!isVertex) {
                return false;
              }
            }
          }
        }

        return true;
      }
      // Advanced clipping functions
      // NUEVA FUNCIÓN ESPECÍFICA SOLO PARA CORTES VERTICALES
      clipPolygonByVerticalLine(polygon, x, keepLeft = true) {
        if (polygon.length === 0) return [];
        const result = [];
        for (let i = 0; i < polygon.length; i++) {
          const current = polygon[i];
          const next = polygon[(i + 1) % polygon.length];
          const currentInside = keepLeft ? current.x <= x : current.x >= x;
          const nextInside = keepLeft ? next.x <= x : next.x >= x;
          // Si el punto actual está dentro, lo agregamos
          if (currentInside) {
            result.push({ x: current.x, y: current.y });
          }
          // Si hay un cambio de estado entre current y next, hay intersección
          if (currentInside !== nextInside) {
            // Solo calcular intersección si realmente cruza la línea vertical
            if (Math.abs(current.x - next.x) > 1e-10) {
              const t = (x - current.x) / (next.x - current.x);
              const intersection = {
                x: x,
                y: current.y + t * (next.y - current.y),
              };
              // Evitar duplicados
              const lastPoint = result[result.length - 1];
              if (
                !lastPoint ||
                Math.abs(lastPoint.x - intersection.x) > 1e-10 ||
                Math.abs(lastPoint.y - intersection.y) > 1e-10
              ) {
                result.push(intersection);
              }
            }
          }
        }
        return result;
      }
      clipPolygonByLine(polygon, lineStart, lineEnd, keepLeft = true) {
        if (polygon.length === 0) return [];
        const result = [];
        for (let i = 0; i < polygon.length; i++) {
          const current = polygon[i];
          const previous = polygon[i === 0 ? polygon.length - 1 : i - 1];
          const currentInside = this.isPointOnSide(
            current,
            lineStart,
            lineEnd,
            keepLeft
          );
          const previousInside = this.isPointOnSide(
            previous,
            lineStart,
            lineEnd,
            keepLeft
          );
          if (currentInside) {
            if (!previousInside) {
              const intersection = this.lineIntersection(
                previous,
                current,
                lineStart,
                lineEnd
              );
              if (intersection) result.push(intersection);
            }
            result.push({ x: current.x, y: current.y });
          } else if (previousInside) {
            const intersection = this.lineIntersection(
              previous,
              current,
              lineStart,
              lineEnd
            );
            if (intersection) result.push(intersection);
          }
        }
        return result;
      }
      isPointOnSide(point, lineStart, lineEnd, keepLeft) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        const cross =
          (point.x - lineStart.x) * dy - (point.y - lineStart.y) * dx;
        return keepLeft ? cross >= 0 : cross <= 0;
      }
      getPerpendicularDirection(lineStart, lineEnd) {
        const dx = lineEnd.x - lineStart.x;
        const dy = lineEnd.y - lineStart.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        return {
          x: -dy / length,
          y: dx / length,
        };
      }
      // FUNCIONES ADAPTATIVAS PARA ZOOM - MEJORADAS
      // FUNCIONES PARA TEXTO FIJO EN PANTALLA
      drawTextInScreen(ctx, text, worldX, worldY, options = {}) {
        const {
          fontSize = 12,
          color = '#ffffff',
          backgroundColor = 'rgba(0, 0, 0, 0.8)',
          offsetX = 0,
          offsetY = 0,
          align = 'center'
        } = options;
        // Convertir coordenadas del mundo a pantalla
        const screenX = worldX * this.scale + this.offsetX + offsetX;
        const screenY = worldY * this.scale + this.offsetY + offsetY;
        // Dibujar en coordenadas de pantalla (resetear transformación)
        ctx.save();
        ctx.resetTransform();
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';

        // Dibujar texto
        ctx.fillStyle = color;
        ctx.fillText(text, screenX, screenY);
        ctx.restore();
      }
      drawLineInScreen(ctx, worldX1, worldY1, worldX2, worldY2, options = {}) {
        const { color = '#ffffff', width = 1, dash = null } = options;
        const screenX1 = worldX1 * this.scale + this.offsetX;
        const screenY1 = worldY1 * this.scale + this.offsetY;
        const screenX2 = worldX2 * this.scale + this.offsetX;
        const screenY2 = worldY2 * this.scale + this.offsetY;
        ctx.save();
        ctx.resetTransform();
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        if (dash) {
          ctx.setLineDash(dash);
        }
        ctx.beginPath();
        ctx.moveTo(screenX1, screenY1);
        ctx.lineTo(screenX2, screenY2);
        ctx.stroke();
        if (dash) {
          ctx.setLineDash([]);
        }
        ctx.restore();
      }
      drawCircleInScreen(ctx, worldX, worldY, radius, options = {}) {
        const { fillColor = '#ffffff', strokeColor = null, strokeWidth = 1 } = options;
        const screenX = worldX * this.scale + this.offsetX;
        const screenY = worldY * this.scale + this.offsetY;
        ctx.save();
        ctx.resetTransform();
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        if (strokeColor) {
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        }
        ctx.restore();
      }

      drawRotationalCenter(ctx) {
        if (!this.rotationalCenter) return;
        // Dibujar punto central con tamaño fijo en pantalla
        this.drawCircleInScreen(ctx, this.rotationalCenter.x, this.rotationalCenter.y, 8, {
          fillColor: '#ff4444',
          strokeColor: '#ffffff',
          strokeWidth: 2
        });
        // Dibujar cruz para indicar centro de rotación
        const crossSize = 15;
        this.drawLineInScreen(
          ctx,
          this.rotationalCenter.x - crossSize / this.scale,
          this.rotationalCenter.y,
          this.rotationalCenter.x + crossSize / this.scale,
          this.rotationalCenter.y,
          { color: '#ff4444', width: 2 }
        );
        this.drawLineInScreen(
          ctx,
          this.rotationalCenter.x,
          this.rotationalCenter.y - crossSize / this.scale,
          this.rotationalCenter.x,
          this.rotationalCenter.y + crossSize / this.scale,
          { color: '#ff4444', width: 2 }
        );
        // Etiqueta del centro de rotación
        this.drawTextInScreen(ctx, "CENTRO DE ROTACIÓN", this.rotationalCenter.x, this.rotationalCenter.y, {
          fontSize: 12,
          color: '#ff4444',
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          offsetY: -25
        });
        // Dibujar círculo indicativo del radio de operación
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 68, 68, 0.3)';
        ctx.lineWidth = 1 / this.scale;
        ctx.setLineDash([10 / this.scale, 5 / this.scale]);
        ctx.beginPath();
        ctx.arc(this.rotationalCenter.x, this.rotationalCenter.y, 50 / this.scale, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      // Division algorithms corregidos
      async dividePolygon() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon || activePolygon.points.length < 3) {
          this.showStatus("Se necesita un polígono válido", "error");
          return;
        }
        if (!this.isValidPolygon(activePolygon.points)) {
          this.showStatus(
            "El polígono no es válido (se auto-intersecta)",
            "error"
          );
          return;
        }
        const method = document.getElementById("divisionMethod").value;
        const axis = document.getElementById("divisionAxis").value;
        const precision = parseFloat(
          document.getElementById("precision").value
        );
        if (axis === "auxiliary" && !this.auxiliaryLine) {
          this.showStatus(
            "Se necesita una línea auxiliar para este método",
            "error"
          );
          return;
        }
        this.showStatus("Calculando división...", "warning");
        this.updateProgress(0, "Iniciando cálculos...");
        try {
          let results = [];
          switch (method) {
            case "equal":
              const numParts = parseInt(
                document.getElementById("numParts").value
              );
              results = await this.dividePolygonEqualParts(
                activePolygon.points,
                numParts,
                axis,
                precision
              );
              break;
            case "specific":
              const specificArea = parseFloat(
                document.getElementById("specificArea").value
              );
              results = await this.divideBySpecificArea(
                activePolygon.points,
                specificArea,
                axis,
                precision
              );
              break;
          }
          // Guardar divisiones para este polígono específico
          this.polygonDivisions.set(activePolygon.id, results);
          this.updateResults(results);
          this.updateProgress(
            100,
            `¡División completada! (${this.totalIterations} iteraciones)`
          );
          this.showStatus(
            `División exitosa: ${results.length} lotes creados`,
            "success"
          );
        } catch (error) {
          console.error("Error during division:", error);
          this.showStatus(
            "Error durante la división: " + error.message,
            "error"
          );
        }
        if (axis === "rotational" && !this.rotationalCenter) {
          this.showStatus("Se necesita establecer un punto de rotación", "error");
          return;
        }
      }
      async dividePolygonEqualParts(
        polygonPoints,
        numParts,
        axis = "x",
        tolerance = 0.0001
      ) {
        let currentPolygon = [...polygonPoints];
        const results = [];
        const totalArea = this.calculateArea(polygonPoints);
        const targetAreaPerPart = totalArea / numParts;
        this.totalIterations = 0;
        for (let i = 0; i < numParts - 1; i++) {
          if (currentPolygon.length < 3) {
            throw new Error(
              `No se puede crear la parte ${i + 1}: polígono insuficiente`
            );
          }
          const result = await this.findExactDivision(
            targetAreaPerPart,
            currentPolygon,
            axis,
            tolerance
          );
          if (result && result.cutPolygon.length >= 3) {
            results.push({
              name: `Lote ${i + 1}`,
              points: result.cutPolygon,
              area: result.area,
              targetArea: targetAreaPerPart,
              error: result.error || 0,
              perimeter: this.calculatePerimeter(result.cutPolygon),
            });
            currentPolygon = result.remainingPolygon;
            const progress = ((i + 1) / numParts) * 100;
            this.updateProgress(progress, `Lote ${i + 1} completado`);
          } else {
            throw new Error(
              `No se pudo crear la parte ${i + 1} con área exacta`
            );
          }
        }
        // Add remaining polygon as last part
        if (currentPolygon.length >= 3) {
          const remainingArea = this.calculateArea(currentPolygon);
          results.push({
            name: `Lote ${results.length + 1}`,
            points: currentPolygon,
            area: remainingArea,
            targetArea: targetAreaPerPart,
            error: Math.abs(remainingArea - targetAreaPerPart),
            perimeter: this.calculatePerimeter(currentPolygon),
          });
        }
        return results;
      }
      // Función corregida para cortes verticales y horizontales


      // === NUEVAS FUNCIONES PARA CREACIÓN INDIVIDUAL ===
      startIndividualLotCreation() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon || activePolygon.points.length < 3) {
          this.showStatus("Se necesita un polígono válido", "error");
          return;
        }
        if (!this.isValidPolygon(activePolygon.points)) {
          this.showStatus("El polígono no es válido (se auto-intersecta)", "error");
          return;
        }
        this.individualLotMode = true;
        this.tempPolygonForIndividual = [...activePolygon.points];
        this.individualLotHistory = [];
        this.currentIndividualStep = 0;
        // Mostrar panel de creación individual
        this.showIndividualLotPanel(true);
        // Actualizar información del polígono restante
        this.updateRemainingPolygonInfo();
        this.showStatus("Modo de creación individual activado", "success");
      }
      createSingleLot() {
        if (!this.individualLotMode || !this.tempPolygonForIndividual) {
          this.showStatus("Debe activar el modo de creación individual primero", "error");
          return;
        }
        const lotAreaInput = document.getElementById("individualLotArea");
        const targetArea = parseFloat(lotAreaInput.value);
        if (isNaN(targetArea) || targetArea <= 0) {
          this.showStatus("Ingrese un área válida", "error");
          return;
        }
        const remainingArea = this.calculateArea(this.tempPolygonForIndividual);
        if (targetArea > remainingArea * 0.95) {
          this.showStatus("El área solicitada es muy grande para el polígono restante", "error");
          return;
        }
        this.pendingLotArea = targetArea;
        // Mostrar controles de confirmación
        this.showLotCreationControls(true);
        this.updateLotPreview();
        this.showStatus(`Preparando lote de ${targetArea.toFixed(3)} m². Use los controles para ajustar.`, "warning");
      }
      async updateLotPreview() {
        if (!this.tempPolygonForIndividual || this.pendingLotArea <= 0) return;
        try {
          const axis = document.getElementById("individualDivisionAxis").value;
          const tolerance = 0.0001;
          const result = await this.findExactDivision(
            this.pendingLotArea,
            this.tempPolygonForIndividual,
            axis,
            tolerance
          );
          if (result && result.cutPolygon.length >= 3) {
            // Guardar el resultado temporal para mostrar preview
            this.pendingLotResult = result;
            // Actualizar información del lote
            this.updatePendingLotInfo(result);
            this.showStatus(`Lote calculado: ${result.area.toFixed(3)} m² (Error: ${result.error.toFixed(3)} m²)`, "success");
          } else {
            this.pendingLotResult = null;
            this.showStatus("No se pudo crear el lote con el área especificada", "error");
          }
        } catch (error) {
          this.pendingLotResult = null;
          this.showStatus("Error al calcular el lote: " + error.message, "error");
        }
      }
      confirmIndividualLot() {
        if (!this.pendingLotResult) {
          this.showStatus("No hay un lote calculado para confirmar", "error");
          return;
        }
        const result = this.pendingLotResult;
        this.currentIndividualStep++;
        // Guardar estado actual para poder deshacer
        this.individualLotHistory.push({
          step: this.currentIndividualStep,
          polygonBefore: [...this.tempPolygonForIndividual],
          createdLot: {
            name: `Lote Individual ${this.currentIndividualStep}`,
            points: [...result.cutPolygon],
            area: result.area,
            targetArea: this.pendingLotArea,
            error: result.error,
            perimeter: this.calculatePerimeter(result.cutPolygon),
          }
        });
        // Actualizar polígono restante
        this.tempPolygonForIndividual = result.remainingPolygon;
        // Agregar el lote a las divisiones del polígono activo
        const activePolygon = this.getActivePolygon();
        if (!this.polygonDivisions.has(activePolygon.id)) {
          this.polygonDivisions.set(activePolygon.id, []);
        }
        const divisions = this.polygonDivisions.get(activePolygon.id);
        divisions.push(this.individualLotHistory[this.individualLotHistory.length - 1].createdLot);
        // Limpiar estado temporal
        this.pendingLotResult = null;
        this.pendingLotArea = 0;
        // Actualizar interfaz
        this.updateResults(divisions);
        this.updateRemainingPolygonInfo();
        this.showLotCreationControls(false);
        // Limpiar campo de área
        document.getElementById("individualLotArea").value = "";
        this.showStatus(`Lote ${this.currentIndividualStep} creado exitosamente`, "success");
      }
      cancelIndividualLot() {
        this.pendingLotResult = null;
        this.pendingLotArea = 0;
        this.showLotCreationControls(false);
        document.getElementById("individualLotArea").value = "";
        this.showStatus("Creación de lote cancelada", "info");
      }
      undoLastIndividualLot() {
        if (this.individualLotHistory.length === 0) {
          this.showStatus("No hay operaciones para deshacer", "warning");
          return;
        }
        const lastOperation = this.individualLotHistory.pop();
        this.tempPolygonForIndividual = lastOperation.polygonBefore;
        this.currentIndividualStep--;
        // Remover el último lote de las divisiones
        const activePolygon = this.getActivePolygon();
        const divisions = this.polygonDivisions.get(activePolygon.id) || [];
        // Buscar y remover el lote correspondiente
        const lotIndex = divisions.findIndex(div =>
          div.name === lastOperation.createdLot.name
        );
        if (lotIndex >= 0) {
          divisions.splice(lotIndex, 1);
        }
        this.updateResults(divisions);
        this.updateRemainingPolygonInfo();
        this.showStatus(`Lote ${lastOperation.step} deshecho`, "success");
      }
      finishIndividualMode() {
        if (this.individualLotHistory.length === 0) {
          this.showStatus("No se crearon lotes", "info");
        } else {
          this.showStatus(`Modo individual finalizado. ${this.individualLotHistory.length} lotes creados.`, "success");
        }
        // Limpiar estado
        this.individualLotMode = false;
        this.tempPolygonForIndividual = null;
        this.pendingLotResult = null;
        this.pendingLotArea = 0;
        this.individualLotHistory = [];
        this.currentIndividualStep = 0;
        // Ocultar panel
        this.showIndividualLotPanel(false);
        this.showLotCreationControls(false);
      }
      // === FUNCIONES DE INTERFAZ ===

      setCurveResolution(resolution) {
        this.curveResolution = Math.max(8, Math.min(200, parseInt(resolution)));
        // Re-interpolar curvas existentes si hay datos de curva guardados
        this.curveData.forEach((curveData, polygonIndex) => {
          if (polygonIndex < this.polygons.length) {
            const polygon = this.polygons[polygonIndex];
            // Aquí podrías re-generar los puntos si fuera necesario
            // Por ahora solo mostramos el estado
            console.log(`Polígono ${polygonIndex + 1} contiene curvas del tipo: ${curveData.type}`);
          }
        });
        this.showStatus(`Resolución de curvas establecida a ${this.curveResolution} puntos por curva`, "success");
      }
      showIndividualLotPanel(show) {
        const panel = document.getElementById("individualLotPanel");
        if (panel) {
          panel.style.display = show ? "block" : "none";
        }
      }
      showLotCreationControls(show) {
        const controls = document.getElementById("lotCreationControls");
        if (controls) {
          controls.style.display = show ? "block" : "none";
        }
      }
      updateRemainingPolygonInfo() {
        if (!this.tempPolygonForIndividual) return;
        const remainingArea = this.calculateArea(this.tempPolygonForIndividual);
        const remainingPerimeter = this.calculatePerimeter(this.tempPolygonForIndividual);
        const infoElement = document.getElementById("remainingPolygonInfo");
        if (infoElement) {
          infoElement.innerHTML = `
<strong>Polígono Restante:</strong><br>
Área: ${remainingArea.toFixed(3)} m²<br>
Perímetro: ${remainingPerimeter.toFixed(3)} m<br>
Lotes creados: ${this.currentIndividualStep}
`;
        }
      }
      updatePendingLotInfo(result) {
        const infoElement = document.getElementById("pendingLotInfo");
        if (infoElement && result) {
          const errorPercent = ((result.error / this.pendingLotArea) * 100).toFixed(4);
          infoElement.innerHTML = `
<strong>Lote Calculado:</strong><br>
Área objetivo: ${this.pendingLotArea.toFixed(3)} m²<br>
Área calculada: ${result.area.toFixed(3)} m²<br>
Error: ${result.error.toFixed(3)} m² (${errorPercent}%)<br>
Perímetro: ${this.calculatePerimeter(result.cutPolygon).toFixed(3)} m
`;
        }
      }
      // MODIFICA SOLO LA PARTE DEL CORTE VERTICAL EN findExactDivision
      async findExactDivision(
        targetArea,
        remainingPolygon,
        axis = "x",
        tolerance = 0.0001,
        maxIterations = 2000
      ) {
        if (remainingPolygon.length < 3) return null;
        const bounds = this.getBounds(remainingPolygon);
        const polygonArea = this.calculateArea(remainingPolygon);
        if (targetArea >= polygonArea - tolerance) {
          return {
            cutPolygon: [...remainingPolygon],
            remainingPolygon: [],
            area: polygonArea,
            iterations: 0,
          };
        }
        let iterations = 0;
        let bestResult = null;
        let bestError = Infinity;
        if (axis === "auxiliary" && this.auxiliaryLine) {
          return await this.findDivisionByAuxiliaryLine(
            targetArea,
            remainingPolygon,
            tolerance,
            maxIterations
          );
        }
        // === NUEVO: DIVISIÓN ROTATORIA ===
        if (axis === "rotational" && this.rotationalCenter) {
          return await this.findRotationalDivision(
            targetArea,
            remainingPolygon,
            this.rotationalCenter,
            this.rotationalConvergence,
            this.maxRotationalIterations
          );
        }
        let left, right, cutLineP1, cutLineP2;
        // Configurar líneas de corte según el eje
        if (axis === "x") {
          left = bounds.minX;
          right = bounds.maxX;
        } else if (axis === "y") {
          left = bounds.minY;
          right = bounds.maxY;
        }
        while (
          iterations < maxIterations &&
          right - left > tolerance * 0.0001
        ) {
          const mid = (left + right) / 2;
          let cutPolygon, restPolygon;
          if (axis === "x") {
            // USAR LA NUEVA FUNCIÓN ESPECÍFICA PARA VERTICAL
            cutPolygon = this.clipPolygonByVerticalLine(
              remainingPolygon,
              mid,
              true
            );
            restPolygon = this.clipPolygonByVerticalLine(
              remainingPolygon,
              mid,
              false
            );
          } else if (axis === "y") {
            // MANTENER EL MÉTODO ORIGINAL PARA HORIZONTAL
            cutLineP1 = { x: bounds.minX - 1000, y: mid };
            cutLineP2 = { x: bounds.maxX + 1000, y: mid };
            cutPolygon = this.clipPolygonByLine(
              remainingPolygon,
              cutLineP1,
              cutLineP2,
              true
            );
            restPolygon = this.clipPolygonByLine(
              remainingPolygon,
              cutLineP1,
              cutLineP2,
              false
            );
          }
          if (cutPolygon.length < 3) {
            if (targetArea < polygonArea / 2) {
              right = mid;
            } else {
              left = mid;
            }
            iterations++;
            continue;
          }
          const cutArea = this.calculateArea(cutPolygon);
          const error = Math.abs(cutArea - targetArea);
          if (error < bestError) {
            bestError = error;
            bestResult = {
              cutPolygon,
              remainingPolygon: restPolygon,
              area: cutArea,
              iterations: iterations + 1,
              cutLine: mid,
              error: error,
            };
          }
          if (error <= tolerance) break;
          if (cutArea < targetArea) {
            left = mid;
          } else {
            right = mid;
          }
          iterations++;
          if (iterations % 50 === 0) {
            const progress = Math.min(95, (iterations / maxIterations) * 100);
            this.updateProgress(
              progress,
              `Calculando... (${iterations}/${maxIterations})`
            );
            await this.sleep(1);
          }
        }
        this.totalIterations += iterations;
        return bestResult;
      }
      async findDivisionByAuxiliaryLine(
        targetArea,
        polygon,
        tolerance = 0.0001,
        maxIterations = 2000
      ) {
        const bounds = this.getBounds(polygon);
        const perpDir = this.getPerpendicularDirection(
          this.auxiliaryLine.start,
          this.auxiliaryLine.end
        );
        // Find range along auxiliary line
        const auxStart = this.auxiliaryLine.start;
        const auxDir = {
          x: this.auxiliaryLine.end.x - this.auxiliaryLine.start.x,
          y: this.auxiliaryLine.end.y - this.auxiliaryLine.start.y,
        };
        const auxLength = Math.sqrt(
          auxDir.x * auxDir.x + auxDir.y * auxDir.y
        );
        auxDir.x /= auxLength;
        auxDir.y /= auxLength;
        let minT = -1000,
          maxT = 1000;
        let iterations = 0;
        let bestResult = null;
        let bestError = Infinity;
        while (
          iterations < maxIterations &&
          maxT - minT > tolerance * 0.0001
        ) {
          const midT = (minT + maxT) / 2;
          const cutLineStart = {
            x: auxStart.x + midT * auxDir.x + perpDir.x * 1000,
            y: auxStart.y + midT * auxDir.y + perpDir.y * 1000,
          };
          const cutLineEnd = {
            x: auxStart.x + midT * auxDir.x - perpDir.x * 1000,
            y: auxStart.y + midT * auxDir.y - perpDir.y * 1000,
          };
          const cutPolygon = this.clipPolygonByLine(
            polygon,
            cutLineStart,
            cutLineEnd,
            true
          );
          const restPolygon = this.clipPolygonByLine(
            polygon,
            cutLineStart,
            cutLineEnd,
            false
          );
          if (cutPolygon.length < 3) {
            minT = midT;
            iterations++;
            continue;
          }
          const cutArea = this.calculateArea(cutPolygon);
          const error = Math.abs(cutArea - targetArea);
          if (error < bestError) {
            bestError = error;
            bestResult = {
              cutPolygon,
              remainingPolygon: restPolygon,
              area: cutArea,
              iterations: iterations + 1,
              error: error,
            };
          }
          if (error <= tolerance) break;
          if (cutArea < targetArea) {
            minT = midT;
          } else {
            maxT = midT;
          }
          iterations++;
          if (iterations % 50 === 0) {
            const progress = Math.min(95, (iterations / maxIterations) * 100);
            this.updateProgress(
              progress,
              `Calculando con línea auxiliar... (${iterations}/${maxIterations})`
            );
            await this.sleep(1);
          }
        }
        this.totalIterations += iterations;
        return bestResult;
      }
      async divideBySpecificArea(
        polygonPoints,
        targetArea,
        axis = "x",
        tolerance = 0.0001
      ) {
        let currentPolygon = [...polygonPoints];
        const results = [];
        let index = 1;
        this.totalIterations = 0;
        const totalArea = this.calculateArea(polygonPoints);
        const estimatedParts = Math.ceil(totalArea / targetArea);
        while (currentPolygon.length >= 3) {
          const currentArea = this.calculateArea(currentPolygon);
          if (currentArea < targetArea * 0.5) {
            results.push({
              name: `Lote ${index}`,
              points: currentPolygon,
              area: currentArea,
              targetArea,
              error: Math.abs(currentArea - targetArea),
              perimeter: this.calculatePerimeter(currentPolygon),
            });
            break;
          }
          const result = await this.findExactDivision(
            targetArea,
            currentPolygon,
            axis,
            tolerance
          );
          if (result && result.cutPolygon.length >= 3) {
            results.push({
              name: `Lote ${index}`,
              points: result.cutPolygon,
              area: result.area,
              targetArea,
              error: result.error || 0,
              perimeter: this.calculatePerimeter(result.cutPolygon),
            });
            currentPolygon = result.remainingPolygon;
            index++;
            const progress = Math.min(
              95,
              (results.length / estimatedParts) * 100
            );
            this.updateProgress(progress, `Lote ${index - 1} completado`);
          } else {
            throw new Error(
              `No se pudo crear el lote ${index} con área exacta`
            );
          }
        }
        return results;
      }
      // Export functions corregidas

      // === NUEVAS FUNCIONES DEL SISTEMA DE SNAP ===
      updateSnapPoints() {
        this.snapPoints = [];
        if (!this.snapEnabled) return;
        // Obtener todos los puntos de todos los polígonos
        this.polygons.forEach(polygon => {
          if (this.snapVertex) {
            // Agregar vértices
            polygon.points.forEach(point => {
              this.snapPoints.push({
                x: point.x,
                y: point.y,
                type: 'vertex',
                polygonId: polygon.id
              });
            });
          }
          if (this.snapMidpoint && polygon.points.length >= 2) {
            // Agregar puntos medios
            for (let i = 0; i < polygon.points.length; i++) {
              const p1 = polygon.points[i];
              const p2 = polygon.points[(i + 1) % polygon.points.length];
              if (polygon.points.length < 3 && i === polygon.points.length - 1) break;
              this.snapPoints.push({
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
                type: 'midpoint',
                polygonId: polygon.id,
                segmentIndex: i
              });
            }
          }
        });
        // Agregar puntos de grid si está habilitado
        if (this.snapGrid) {
          this.addGridSnapPoints();
        }
      }
      addGridSnapPoints() {
        const gridSize = this.calculateGridSize();
        const bounds = this.getViewBounds();
        for (let x = Math.floor(bounds.minX / gridSize) * gridSize;
          x <= bounds.maxX;
          x += gridSize) {
          for (let y = Math.floor(bounds.minY / gridSize) * gridSize;
            y <= bounds.maxY;
            y += gridSize) {
            this.snapPoints.push({
              x: x,
              y: y,
              type: 'grid'
            });
          }
        }
      }
      getViewBounds() {
        const viewLeft = -this.offsetX / this.scale;
        const viewTop = -this.offsetY / this.scale;
        const viewRight = viewLeft + this.canvas.width / this.scale;
        const viewBottom = viewTop + this.canvas.height / this.scale;
        return {
          minX: viewLeft,
          maxX: viewRight,
          minY: viewTop,
          maxY: viewBottom
        };
      }
      findSnapPoint(worldX, worldY) {
        if (!this.snapEnabled) return null;
        // Actualizar puntos de snap
        this.updateSnapPoints();
        let closestPoint = null;
        let minDistance = Infinity;
        // Convertir tolerancia de píxeles a unidades del mundo
        const tolerance = this.snapTolerance / this.scale;
        this.snapPoints.forEach(snapPoint => {
          const distance = Math.sqrt(
            Math.pow(snapPoint.x - worldX, 2) +
            Math.pow(snapPoint.y - worldY, 2)
          );
          if (distance < tolerance && distance < minDistance) {
            minDistance = distance;
            closestPoint = {
              point: { x: snapPoint.x, y: snapPoint.y },
              type: snapPoint.type,
              distance: distance,
              polygonId: snapPoint.polygonId,
              segmentIndex: snapPoint.segmentIndex
            };
          }
        });
        return closestPoint;
      }
      updatePreviewLine(endPoint) {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon || activePolygon.points.length === 0) {
          this.previewLine = null;
          return;
        }
        const lastPoint = activePolygon.points[activePolygon.points.length - 1];
        this.previewLine = {
          start: lastPoint,
          end: endPoint
        };
      }
      showSnapIndicator(type, screenX, screenY) {
        const indicator = document.getElementById('snapIndicator');
        if (!indicator) return;
        const typeNames = {
          'vertex': '🔴 Vértice',
          'midpoint': '🟡 Punto Medio',
          'grid': '📐 Grid'
        };
        indicator.textContent = typeNames[type] || type;
        indicator.style.left = `${screenX + 10}px`;
        indicator.style.top = `${screenY - 30}px`;
        indicator.style.display = 'block';
        // Ocultar después de 1 segundo
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 1000);
      }

      // Modificar función draw() para incluir visualización de snap
      drawSnapPoints(ctx) {
        if (!this.snapEnabled) return;
        this.snapPoints.forEach(snapPoint => {
          const screenPos = this.worldToScreen(snapPoint.x, snapPoint.y);
          if (this.isPointInView(screenPos.x, screenPos.y)) {
            ctx.save();
            ctx.resetTransform();
            ctx.beginPath();
            switch (snapPoint.type) {
              case 'vertex':
                ctx.arc(screenPos.x, screenPos.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                ctx.strokeStyle = '#ffffff';
                break;
              case 'midpoint':
                ctx.rect(screenPos.x - 3, screenPos.y - 3, 6, 6);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
                ctx.strokeStyle = '#ffffff';
                break;
              case 'grid':
                ctx.arc(screenPos.x, screenPos.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 181, 246, 0.5)';
                ctx.strokeStyle = '#ffffff';
                break;
            }
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
          }
        });
        // Dibujar punto de snap actual más destacado
        if (this.currentSnapPoint) {
          const screenPos = this.worldToScreen(
            this.currentSnapPoint.point.x,
            this.currentSnapPoint.point.y
          );
          ctx.save();
          ctx.resetTransform();
          ctx.beginPath();
          ctx.arc(screenPos.x, screenPos.y, 8, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
      }
      drawPreviewLine(ctx) {
        if (!this.previewLine) return;
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.6)';
        ctx.lineWidth = 1 / this.scale;
        ctx.setLineDash([5 / this.scale, 5 / this.scale]);
        ctx.beginPath();
        ctx.moveTo(this.previewLine.start.x, this.previewLine.start.y);
        ctx.lineTo(this.previewLine.end.x, this.previewLine.end.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      worldToScreen(worldX, worldY) {
        return {
          x: worldX * this.scale + this.offsetX,
          y: worldY * this.scale + this.offsetY
        };
      }
      isPointInView(screenX, screenY) {
        return screenX >= -10 && screenX <= this.canvas.width + 10 &&
          screenY >= -10 && screenY <= this.canvas.height + 10;
      }
      // Export functions corregidas - Versión simplificada
      exportDXF() {
        const divisions = this.getCurrentDivisions();
        if (divisions.length === 0) {
          this.showStatus("No hay lotes para exportar", "warning");
          return;
        }

        let dxfContent = `0\nSECTION\n2\nENTITIES\n`;

        // Exportar solo las divisiones (lotes) del polígono activo
        divisions.forEach((division, index) => {
          const layerName = `Lote_${index + 1}`;
          dxfContent += `0\nPOLYLINE\n8\n${layerName}\n66\n1\n10\n0.0\n20\n0.0\n30\n0.0\n70\n1\n`;

          // Agregar vértices del polígono
          division.points.forEach((point) => {
            dxfContent += `0\nVERTEX\n8\n${layerName}\n10\n${point.x.toFixed(8)}\n20\n${point.y.toFixed(8)}\n30\n0.0\n`;
          });

          dxfContent += `0\nSEQEND\n`;
        });

        dxfContent += `0\nENDSEC\n0\nEOF\n`;

        this.downloadFile(dxfContent, `lotes_${Date.now()}.dxf`, "application/dxf");
        this.showStatus("Archivo DXF de lotes exportado exitosamente", "success");
      }

      exportAllDXF() {
        if (this.polygons.length === 0) {
          this.showStatus("No hay polígonos para exportar", "warning");
          return;
        }

        let dxfContent = `0\nSECTION\n2\nENTITIES\n`;
        let lotCount = 0;

        // Exportar todas las divisiones de todos los polígonos
        this.polygons.forEach((polygon, polyIndex) => {
          const divisions = this.polygonDivisions.get(polygon.id) || [];
          divisions.forEach((division, divIndex) => {
            lotCount++;
            const layerName = `Lote_${lotCount}`;
            dxfContent += `0\nPOLYLINE\n8\n${layerName}\n66\n1\n10\n0.0\n20\n0.0\n30\n0.0\n70\n1\n`;

            // Agregar vértices del polígono
            division.points.forEach((point) => {
              dxfContent += `0\nVERTEX\n8\n${layerName}\n10\n${point.x.toFixed(8)}\n20\n${point.y.toFixed(8)}\n30\n0.0\n`;
            });

            dxfContent += `0\nSEQEND\n`;
          });
        });

        if (lotCount === 0) {
          this.showStatus("No hay lotes para exportar", "warning");
          return;
        }

        dxfContent += `0\nENDSEC\n0\nEOF\n`;

        this.downloadFile(dxfContent, `todos_lotes_${Date.now()}.dxf`, "application/dxf");
        this.showStatus(`Todos los lotes (${lotCount}) exportados a DXF exitosamente`, "success");
      }
      exportTXT() {
        const divisions = this.getCurrentDivisions();
        if (divisions.length === 0) {
          this.showStatus("No hay datos para exportar", "warning");
          return;
        }
        let txtContent = this.generateTXTContent();
        this.downloadFile(
          txtContent,
          `coordenadas_${Date.now()}.txt`,
          "text/plain"
        );
        this.showStatus("Archivo TXT exportado exitosamente", "success");
      }

      generateTXTContent() {
        const divisions = this.getCurrentDivisions();
        const activePolygon = this.getActivePolygon();
        let content = "Nro_Punto,Este,Norte,Cota,Descripcion\n";
        let pointNumber = 1;
        // Original polygon points
        if (activePolygon && activePolygon.points.length >= 3) {
          activePolygon.points.forEach((point, index) => {
            content += `${pointNumber},${point.x.toFixed(
              3
            )},${point.y.toFixed(3)},0.000,ORIGINAL_P${index + 1}\n`;
            pointNumber++;
          });
        }
        // Division points
        divisions.forEach((division, divIndex) => {
          division.points.forEach((point, ptIndex) => {
            content += `${pointNumber},${point.x.toFixed(
              3
            )},${point.y.toFixed(3)},0.000,LOTE${divIndex + 1}_P${ptIndex + 1
              }\n`;
            pointNumber++;
          });
        });
        // Add summary
        content += "\n--- RESUMEN ---\n";
        content += `Polygono Original: ${activePolygon
          ? this.calculateArea(activePolygon.points).toFixed(3)
          : 0
          } m²\n`;
        content += `Total Lotes: ${divisions.length}\n`;
        divisions.forEach((division, index) => {
          content += `Lote ${index + 1}: ${division.area.toFixed(
            3
          )} m² (Error: ${division.error.toFixed(3)} m²)\n`;
        });
        return content;
      }
      downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      // UI and drawing functions
      updateProgress(percent, text) {
        const progressFill = document.getElementById("progressFill");
        const progressText = document.getElementById("progressText");
        progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
        progressText.textContent = text || `${percent.toFixed(1)}%`;
      }
      showStatus(message, type = "info") {
        const statusElement = document.getElementById("statusMessage");
        statusElement.textContent = message;
        statusElement.className = `status ${type}`;
        setTimeout(() => {
          statusElement.textContent = "";
          statusElement.className = "status";
        }, 5000);
      }
      updateResults(results) {
        const resultsContainer = document.getElementById("results");
        const exportButtons = document.getElementById("exportButtons");

        if (results.length === 0) {
          resultsContainer.innerHTML = "<p>No hay resultados para el polígono activo</p>";
          exportButtons.style.display = "none";
          return;
        }

        let html = "";
        let totalCalculatedArea = 0;

        results.forEach((result, index) => {
          totalCalculatedArea += result.area;
          const errorPercent = ((result.error / result.targetArea) * 100).toFixed(3);
          html += `
          <div class="result-item">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <strong>${result.name}</strong><br>
                <small>Área: ${result.area.toFixed(3)} m²</small><br>
                <small>Objetivo: ${result.targetArea.toFixed(3)} m²</small><br>
                <small>Error: ${result.error.toFixed(3)} m² (${errorPercent}%)</small><br>
                <small>Perímetro: ${result.perimeter.toFixed(3)} m</small>
              </div>
              <div>
                <button onclick="polygonDivider.convertDivisionToPolygon(${index})"
                  class="btn btn-sm btn-primary"
                  title="Convertir a polígono editable">
                  📝 Editar
                </button>
              </div>
            </div>
          </div>
        `;
        });

        // Agregar botones para convertir todas las divisiones
        if (results.length > 1) {
          html += `
          <div style="margin-top: 10px; text-align: center;">
            <button onclick="polygonDivider.convertAllDivisionsToPolygons()"
              class="btn btn-warning">
              📝 Convertir Todas las Divisiones
            </button>
            <button onclick="polygonDivider.convertAllAndDeleteOriginal()"
              class="btn btn-danger">
              🗑️ Convertir y Eliminar Original
            </button>
          </div>
        `;
        }

        const activePolygon = this.getActivePolygon();
        const originalArea = activePolygon ? this.calculateArea(activePolygon.points) : 0;
        const areaConservation = originalArea > 0 ? ((totalCalculatedArea / originalArea) * 100).toFixed(3) : "0.00";

        html += `
        <div class="info-panel" style="margin-top: 15px;">
          <div class="info-item">
            <span>Área Original:</span>
            <span>${originalArea.toFixed(3)} m²</span>
          </div>
          <div class="info-item">
            <span>Área Total Calculada:</span>
            <span>${totalCalculatedArea.toFixed(3)} m²</span>
          </div>
          <div class="info-item">
            <span>Conservación:</span>
            <span>${areaConservation}%</span>
          </div>
          <div class="info-item">
            <span>Iteraciones Totales:</span>
            <span>${this.totalIterations}</span>
          </div>
        </div>
      `;

        resultsContainer.innerHTML = html;
        exportButtons.style.display = "flex";
      }
      sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      // Drawing and animation
      draw() {
        const ctx = this.ctx;
        ctx.save();

        // Clear canvas
        ctx.fillStyle = "rgba(10, 10, 10, 0.95)";
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Apply transformations
        ctx.translate(this.offsetX, this.offsetY);
        ctx.scale(this.scale, this.scale);

        // Draw grid
        if (this.showGrid) {
          this.drawGrid(ctx);
        }

        // Draw auxiliary line
        if (this.auxiliaryLine) {
          this.drawAuxiliaryLine(ctx);
        }

        // Draw rotational center
        if (this.rotationalCenter) {
          this.drawRotationalCenter(ctx);
        }

        // Draw all polygons (sin divisiones)
        this.drawPolygons(ctx);

        // === IMPORTANTE: Dibujar TODAS las divisiones de TODOS los polígonos ===
        this.drawDivisions(ctx);

        // === NUEVO: Draw individual lot preview ===
        if (this.individualLotMode) {
          this.drawIndividualLotPreview(ctx);
        }

        // Draw dimensions
        if (this.showDimensions) {
          this.drawDimensions(ctx);
        }

        // Draw preview line
        this.drawPreviewLine(ctx);

        // Draw snap points (esto se dibuja en coordenadas de pantalla)
        ctx.restore(); // Restaurar transformaciones primero
        this.drawSnapPoints(ctx); // Dibujar en coordenadas de pantalla
        ctx.save(); // Guardar de nuevo para el siguiente frame
        ctx.restore();
      }
      convertAllAndDeleteOriginal() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;

        const divisions = this.getCurrentDivisions();
        if (divisions.length === 0) {
          this.showStatus("No hay divisiones para convertir", "warning");
          return;
        }

        // Convertir todas las divisiones
        this.convertAllDivisionsToPolygons();

        // Eliminar el polígono original
        const currentIndex = this.activePolygonIndex;
        this.polygons.splice(currentIndex, 1);

        // Eliminar referencias
        this.polygonDivisions.delete(activePolygon.id);
        this.polygonHierarchy.delete(activePolygon.id);

        if (this.polygonParents.has(activePolygon.id)) {
          const parentId = this.polygonParents.get(activePolygon.id);
          const siblings = this.polygonHierarchy.get(parentId) || [];
          const siblingIndex = siblings.indexOf(activePolygon.id);
          if (siblingIndex >= 0) {
            siblings.splice(siblingIndex, 1);
            this.polygonHierarchy.set(parentId, siblings);
          }
          this.polygonParents.delete(activePolygon.id);
        }

        // Actualizar índice activo
        if (this.polygons.length === 0) {
          this.activePolygonIndex = -1;
          this.createNewPolygon();
        } else {
          this.activePolygonIndex = Math.min(currentIndex, this.polygons.length - 1);
        }

        this.updatePolygonList();
        this.updateInfo();
        this.updateResults(this.getCurrentDivisions());

        this.showStatus(
          `Polígono original "${activePolygon.name}" eliminado después de convertir todas las divisiones`,
          "success"
        );
      }
      // === MODIFICAR LA FUNCIÓN DRAW PARA MOSTRAR PREVIEW ===
      // Agregar al final de la función draw(), antes de ctx.restore()
      drawIndividualLotPreview(ctx) {
        if (!this.individualLotMode || !this.pendingLotResult) return;
        // Dibujar polígono restante con color especial
        if (this.tempPolygonForIndividual && this.tempPolygonForIndividual.length >= 3) {
          this.drawPolygon(ctx, this.tempPolygonForIndividual, "rgba(100, 100, 100, 0.3)", "#666666", 1);
        }
        // Dibujar lote pendiente con color destacado
        if (this.pendingLotResult.cutPolygon.length >= 3) {
          this.drawPolygon(ctx, this.pendingLotResult.cutPolygon, "rgba(255, 235, 59, 0.4)", "#ffeb3b", 2);
          // Etiqueta del lote pendiente
          // Etiqueta del lote pendiente con tamaño FIJO
          const centroid = this.getCentroid(this.pendingLotResult.cutPolygon);
          this.drawTextInScreen(ctx, "LOTE PENDIENTE", centroid.x, centroid.y, {
            fontSize: 14,
            color: '#ffeb3b',
            backgroundColor: 'rgba(0, 0, 0, 0.9)'
          });
          this.drawTextInScreen(ctx, `${this.pendingLotResult.area.toFixed(3)} m²`, centroid.x, centroid.y, {
            fontSize: 12,
            color: '#ffeb3b',
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            offsetY: 18
          });
        }
      }
      drawGrid(ctx) {
        // Calcular límites del viewport actual
        const viewLeft = -this.offsetX / this.scale;
        const viewTop = -this.offsetY / this.scale;
        const viewRight = viewLeft + this.canvas.width / this.scale;
        const viewBottom = viewTop + this.canvas.height / this.scale;
        // Expandir los límites para cubrir toda la vista
        const gridSize = this.calculateGridSize();
        const startX = Math.floor(viewLeft / gridSize) * gridSize;
        const endX = Math.ceil(viewRight / gridSize) * gridSize;
        const startY = Math.floor(viewTop / gridSize) * gridSize;
        const endY = Math.ceil(viewBottom / gridSize) * gridSize;
        ctx.strokeStyle = "rgba(100, 181, 246, 0.2)";
        ctx.lineWidth = 1 / this.scale;
        ctx.setLineDash([2 / this.scale, 2 / this.scale]);
        ctx.beginPath();
        // Líneas verticales
        for (let x = startX; x <= endX; x += gridSize) {
          ctx.moveTo(x, startY);
          ctx.lineTo(x, endY);
        }
        // Líneas horizontales
        for (let y = startY; y <= endY; y += gridSize) {
          ctx.moveTo(startX, y);
          ctx.lineTo(endX, y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
      calculateGridSize() {
        // Calcular tamaño de grid basado en el nivel de zoom
        const viewWidth = this.canvas.width / this.scale;
        const targetGridLines = 20;
        const rawGridSize = viewWidth / targetGridLines;
        // Redondear a números agradables
        const magnitude = Math.pow(10, Math.floor(Math.log10(rawGridSize)));
        const normalized = rawGridSize / magnitude;
        let niceGridSize;
        if (normalized <= 1) niceGridSize = 1;
        else if (normalized <= 2) niceGridSize = 2;
        else if (normalized <= 5) niceGridSize = 5;
        else niceGridSize = 10;
        return niceGridSize * magnitude;
      }
      drawAuxiliaryLine(ctx) {
        if (!this.auxiliaryLine) return;
        ctx.strokeStyle = "#ffeb3b";
        ctx.lineWidth = 2 / this.scale;
        ctx.setLineDash([5 / this.scale, 5 / this.scale]);
        ctx.beginPath();
        ctx.moveTo(this.auxiliaryLine.start.x, this.auxiliaryLine.start.y);
        ctx.lineTo(this.auxiliaryLine.end.x, this.auxiliaryLine.end.y);
        ctx.stroke();
        // Draw arrows
        const angle = Math.atan2(
          this.auxiliaryLine.end.y - this.auxiliaryLine.start.y,
          this.auxiliaryLine.end.x - this.auxiliaryLine.start.x
        );
        const arrowLength = 10 / this.scale;
        const arrowAngle = Math.PI / 6;
        // Arrow at end
        ctx.beginPath();
        ctx.moveTo(this.auxiliaryLine.end.x, this.auxiliaryLine.end.y);
        ctx.lineTo(
          this.auxiliaryLine.end.x -
          arrowLength * Math.cos(angle - arrowAngle),
          this.auxiliaryLine.end.y -
          arrowLength * Math.sin(angle - arrowAngle)
        );
        ctx.moveTo(this.auxiliaryLine.end.x, this.auxiliaryLine.end.y);
        ctx.lineTo(
          this.auxiliaryLine.end.x -
          arrowLength * Math.cos(angle + arrowAngle),
          this.auxiliaryLine.end.y -
          arrowLength * Math.sin(angle + arrowAngle)
        );
        ctx.stroke();
        ctx.setLineDash([]);
        // Label
        // Label with better visibility
        // Label with FIXED screen size
        const midX = (this.auxiliaryLine.start.x + this.auxiliaryLine.end.x) / 2;
        const midY = (this.auxiliaryLine.start.y + this.auxiliaryLine.end.y) / 2;
        this.drawTextInScreen(ctx, "LÍNEA AUXILIAR", midX, midY, {
          fontSize: 12,
          color: '#ffeb3b',
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          offsetY: -25
        });
      }
      drawDivisions(ctx) {
        const colors = [
          "#ff9800",
          "#4caf50",
          "#9c27b0",
          "#f44336",
          "#2196f3",
          "#ffeb3b",
          "#795548",
          "#607d8b",
        ];

        // Obtener el polígono activo para comparación
        const activePolygon = this.getActivePolygon();
        const activePolygonId = activePolygon ? activePolygon.id : null;

        // Iterar sobre todos los polígonos para dibujar todas las divisiones
        this.polygons.forEach((polygon, polyIndex) => {
          // Obtener las divisiones de este polígono
          const divisions = this.polygonDivisions.get(polygon.id) || [];

          // Si no hay divisiones, saltar al siguiente polígono
          if (divisions.length === 0) return;

          // Determinar si este polígono es el activo
          const isActive = polygon.id === activePolygonId;

          // Dibujar cada división de este polígono
          divisions.forEach((division, divIndex) => {
            const color = colors[divIndex % colors.length];

            // Estilo según si el polígono es activo o no
            if (isActive) {
              // Polígono activo: dibujar con contorno grueso y etiquetas completas
              this.drawPolygon(ctx, division.points, null, color, 1.5);

              // Dibujar etiquetas
              const centroid = this.getCentroid(division.points);
              this.drawTextInScreen(ctx, division.name, centroid.x, centroid.y, {
                fontSize: 14,
                color: color,
                backgroundColor: 'rgba(0, 0, 0, 0.9)'
              });
              this.drawTextInScreen(ctx, `${division.area.toFixed(3)} m²`, centroid.x, centroid.y, {
                fontSize: 11,
                color: color,
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                offsetY: 18
              });
            } else {
              // Polígono no activo: dibujar con contorno fino y etiquetas más sutiles
              this.drawPolygon(ctx, division.points, null, color, 0.8);

              // Dibujar etiquetas más pequeñas y sutiles
              const centroid = this.getCentroid(division.points);
              this.drawTextInScreen(ctx, division.name, centroid.x, centroid.y, {
                fontSize: 10,
                color: color,
                backgroundColor: 'rgba(0, 0, 0, 0.5)',
                offsetY: -10
              });
            }
          });
        });
      }
      drawPolygons(ctx) {
        this.polygons.forEach((polygon, index) => {
          const isActive = index === this.activePolygonIndex;
          const strokeWidth = isActive ? 2 : 1;
          // Si estamos seleccionando segmentos y es el polígono activo, dibujar segmentos individualmente
          if (isActive && this.isSelectingSegment) {
            this.drawPolygonWithSelectableSegments(
              ctx,
              polygon.points,
              polygon.color,
              strokeWidth
            );
          } else {
            this.drawPolygon(
              ctx,
              polygon.points,
              null,
              polygon.color,
              strokeWidth
            );
          }
          this.drawPoints(ctx, polygon.points, polygon.color, isActive);
          // Draw polygon label
          // Draw polygon label with better visibility
          // Draw polygon label with FIXED size
          if (polygon.points.length >= 3) {
            const centroid = this.getCentroid(polygon.points);
            this.drawTextInScreen(ctx, polygon.name, centroid.x, centroid.y, {
              fontSize: 12,
              color: polygon.color,
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              offsetY: -3 // Offset fijo en píxeles
            });
          }
        });
      }
      // 9. NUEVA FUNCIÓN - AGREGAR:
      drawPolygonWithSelectableSegments(ctx, points, color, lineWidth) {
        if (points.length < 2) return;
        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          if (points.length < 3 && i === points.length - 1) break;
          const isHovered = this.hoveredSegment === i;
          const isSelected = this.selectedSegment === i;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          if (isHovered || isSelected) {
            ctx.strokeStyle = "#ffeb3b";
            ctx.lineWidth = (lineWidth * 2) / this.scale;
            ctx.shadowColor = "#ffeb3b";
            ctx.shadowBlur = 5 / this.scale;
          } else {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth / this.scale;
            ctx.shadowBlur = 0;
          }
          ctx.stroke();
          // Resetear shadow
          ctx.shadowBlur = 0;
          // Dibujar número del segmento si está siendo hover
          if (isHovered) {
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;
            ctx.fillStyle = "#ffeb3b";
            ctx.font = `${8 / this.scale}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(`S${i + 1}`, midX, midY - 10 / this.scale);
          }
        }
      }
      drawPolygon(ctx, points, fillColor, strokeColor, lineWidth = 2) {
        if (points.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
        if (points.length >= 3) {
          ctx.closePath();
          // Solo rellenar si fillColor no es null
          if (fillColor) {
            ctx.fillStyle = fillColor;
            ctx.fill();
          }
        }
        if (strokeColor) {
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = lineWidth / this.scale;
          ctx.stroke();
        }
      }
      drawPoints(ctx, points, color, isActive) {
        points.forEach((point, index) => {
          // Dibujar punto con tamaño fijo en pantalla
          const pointRadius = isActive ? 5 : 3;
          this.drawCircleInScreen(ctx, point.x, point.y, pointRadius, {
            fillColor: color,
            strokeColor: '#ffffff',
            strokeWidth: 1
          });
          if (isActive) {
            // Dibujar índice del punto con tamaño fijo
            this.drawTextInScreen(ctx, index.toString(), point.x, point.y, {
              fontSize: 10,
              color: '#ffffff',
              backgroundColor: 'rgba(0, 0, 0, 0.9)',
              offsetY: -(pointRadius + 12) // Offset en píxeles de pantalla
            });
          }
        });
      }
      drawDimensions(ctx) {
        if (!this.showDimensions) return;
        // Draw dimensions for active polygon
        const activePolygon = this.getActivePolygon();
        if (activePolygon && activePolygon.points.length >= 2) {
          this.drawPolygonDimensionsFixed(ctx, activePolygon.points, activePolygon.color);
        }
        // Draw dimensions for divisions of active polygon
        const divisions = this.getCurrentDivisions();
        divisions.forEach((division, index) => {
          const colors = ["#ff9800", "#4caf50", "#9c27b0", "#f44336"];
          const color = colors[index % colors.length];
          this.drawPolygonDimensionsFixed(ctx, division.points, color);
        });
      }
      drawPolygonDimensionsFixed(ctx, points, color) {
        if (points.length < 2) return;
        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          if (points.length < 3 && i === points.length - 1) break;
          const distance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          // Calcular ángulo del segmento
          const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
          // Calcular offset en coordenadas del mundo
          const offsetDistance = 10 / this.scale; // Distancia fija en píxeles convertida al mundo
          const offsetX = -Math.sin(angle) * offsetDistance;
          const offsetY = Math.cos(angle) * offsetDistance;
          const labelX = midX + offsetX;
          const labelY = midY + offsetY;
          // Dibujar línea de dimensión en coordenadas de pantalla
          this.drawLineInScreen(ctx, midX, midY, labelX, labelY, {
            color: color,
            width: 1,
            dash: [3, 2]
          });
          // MODIFICACIÓN PRINCIPAL: Dibujar texto rotado según el ángulo del segmento
          this.drawTextInScreenRotated(ctx, `${distance.toFixed(2)}m`, labelX, labelY, angle, {
            fontSize: 11,
            color: color,
            backgroundColor: 'rgba(0, 0, 0, 0.8)'
          });
        }
      }
      // Nueva función para dibujar texto rotado en coordenadas de pantalla
      drawTextInScreenRotated(ctx, text, worldX, worldY, rotationAngle, options = {}) {
        const {
          fontSize = 12,
          color = '#ffffff',
          backgroundColor = 'rgba(0, 0, 0, 0.8)',
          offsetX = 0,
          offsetY = 0,
          align = 'center'
        } = options;
        // Convertir coordenadas del mundo a pantalla
        const screenX = worldX * this.scale + this.offsetX + offsetX;
        const screenY = worldY * this.scale + this.offsetY + offsetY;
        // Ajustar rotación para evitar texto cabeza abajo
        let finalAngle = rotationAngle;
        if (rotationAngle > Math.PI / 2 || rotationAngle < -Math.PI / 2) {
          finalAngle = rotationAngle + Math.PI;
        }
        // Dibujar en coordenadas de pantalla (resetear transformación)
        ctx.save();
        ctx.resetTransform();
        // Mover al punto y rotar
        ctx.translate(screenX, screenY);
        ctx.rotate(finalAngle);
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';

        // Dibujar texto
        ctx.fillStyle = color;
        ctx.fillText(text, 0, 0);
        ctx.restore();
      }
      drawPolygonDimensions(ctx, points, color) {
        if (points.length < 2) return;
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = this.getAdaptiveLineWidth(1);
        ctx.font = `${this.getAdaptiveTextSize(10)}px Arial`;
        ctx.textAlign = "center";
        for (let i = 0; i < points.length; i++) {
          const p1 = points[i];
          const p2 = points[(i + 1) % points.length];
          if (points.length < 3 && i === points.length - 1) break;
          const distance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          // Calculate offset for dimension text - tamaño constante
          const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
          const offsetDistance = 15 / this.scale;
          const offsetX = -Math.sin(angle) * offsetDistance;
          const offsetY = Math.cos(angle) * offsetDistance;
          // Draw dimension line
          const dashSize = this.getAdaptiveLineWidth(0.5);
          ctx.setLineDash([dashSize * 3, dashSize * 2]);
          ctx.beginPath();
          ctx.moveTo(midX, midY);
          ctx.lineTo(midX + offsetX, midY + offsetY);
          ctx.stroke();
          ctx.setLineDash([]);
          // Draw dimension text with better visibility
          ctx.save();
          ctx.translate(midX + offsetX, midY + offsetY);

          // Solo rotar si el ángulo no hace el texto ilegible
          const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
          if (normalizedAngle > Math.PI / 4 && normalizedAngle < 3 * Math.PI / 4) {
            ctx.rotate(angle - Math.PI);
          } else if (normalizedAngle > 5 * Math.PI / 4 && normalizedAngle < 7 * Math.PI / 4) {
            ctx.rotate(angle - Math.PI);
          } else {
            ctx.rotate(angle);
          }
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          // Fondo semitransparente para mejor legibilidad

          ctx.fillStyle = color;
          ctx.fillText(`${distance.toFixed(2)}m`, 0, 0);
          ctx.restore();
        }
      }
      animate() {
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
      // NUEVAS FUNCIONES - AGREGAR AQUÍ
      convertDivisionToPolygon(divisionIndex) {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;

        const divisions = this.polygonDivisions.get(activePolygon.id) || [];
        if (divisionIndex < 0 || divisionIndex >= divisions.length) return;

        const division = divisions[divisionIndex];

        // Crear nuevo polígono independiente sin referencia al padre
        const newPolygon = {
          id: Date.now() + Math.random(),
          name: division.name || `Lote ${this.polygons.length + 1}`,
          points: [...division.points],
          color: this.getRandomColor(),
          closed: true,
          // Eliminar parentId para hacerlo completamente independiente
          // parentId: activePolygon.id, 
          originalArea: division.area,
          originalPerimeter: division.perimeter
        };

        this.polygons.push(newPolygon);

        // Eliminar la división convertida
        divisions.splice(divisionIndex, 1);
        this.polygonDivisions.set(activePolygon.id, divisions);

        // No agregar a jerarquía para que sea completamente independiente
        // if (!this.polygonHierarchy.has(activePolygon.id)) {
        //   this.polygonHierarchy.set(activePolygon.id, []);
        // }
        // this.polygonHierarchy.get(activePolygon.id).push(newPolygon.id);
        // this.polygonParents.set(newPolygon.id, activePolygon.id);

        this.updatePolygonList();
        this.updateResults(this.getCurrentDivisions());
        this.showStatus(`${division.name} convertido a polígono editable`, "success");
        return newPolygon;
      }
      convertAllDivisionsToPolygons() {
        const activePolygon = this.getActivePolygon();
        if (!activePolygon) return;

        const divisions = this.getCurrentDivisions();
        if (divisions.length === 0) {
          this.showStatus("No hay divisiones para convertir", "warning");
          return;
        }

        // Confirmar si se desea eliminar el polígono original
        const shouldDeleteOriginal = confirm(
          `¿Desea eliminar el polígono original "${activePolygon.name}" después de convertir todas las divisiones?`
        );

        // Convertir todas las divisiones a polígonos
        const convertedCount = divisions.length;
        for (let i = divisions.length - 1; i >= 0; i--) {
          this.convertDivisionToPolygon(i);
        }

        // Si el usuario confirmó, eliminar el polígono original
        if (shouldDeleteOriginal) {
          // Obtener el índice actual antes de eliminar
          const currentIndex = this.activePolygonIndex;

          // Eliminar el polígono original
          this.polygons.splice(currentIndex, 1);

          // Eliminar referencias en jerarquías
          this.polygonDivisions.delete(activePolygon.id);
          this.polygonHierarchy.delete(activePolygon.id);

          // Si era hijo de otro polígono, actualizar la jerarquía del padre
          if (this.polygonParents.has(activePolygon.id)) {
            const parentId = this.polygonParents.get(activePolygon.id);
            const siblings = this.polygonHierarchy.get(parentId) || [];
            const siblingIndex = siblings.indexOf(activePolygon.id);
            if (siblingIndex >= 0) {
              siblings.splice(siblingIndex, 1);
              this.polygonHierarchy.set(parentId, siblings);
            }
            this.polygonParents.delete(activePolygon.id);
          }

          // Actualizar el índice del polígono activo
          if (this.polygons.length === 0) {
            this.activePolygonIndex = -1;
            this.createNewPolygon();
          } else {
            this.activePolygonIndex = Math.min(currentIndex, this.polygons.length - 1);
          }

          this.showStatus(
            `${convertedCount} divisiones convertidas y polígono original "${activePolygon.name}" eliminado`,
            "success"
          );
        } else {
          this.showStatus(
            `${convertedCount} divisiones convertidas a polígonos editables`,
            "success"
          );
        }

        // Actualizar la interfaz
        this.updatePolygonList();
        this.updateInfo();
        this.updateResults(this.getCurrentDivisions());
      }
      updateRotationalCenterInfo() {
        const infoElement = document.getElementById("rotationalCenterInfo");
        if (infoElement) {
          if (this.rotationalCenter) {
            infoElement.innerHTML = `Centro: X=${this.rotationalCenter.x.toFixed(3)}, Y=${this.rotationalCenter.y.toFixed(3)}`;
            infoElement.style.color = '#4caf50';
          } else {
            infoElement.innerHTML = 'Centro no establecido';
            infoElement.style.color = '#888';
          }
        }
      }
      showPolygonHierarchy() {
        let hierarchyText = "=== JERARQUÍA DE POLÍGONOS ===\n\n";
        const rootPolygons = this.polygons.filter(p => !this.polygonParents.has(p.id));
        rootPolygons.forEach(polygon => {
          hierarchyText += `📁 ${polygon.name}\n`;
          hierarchyText += ` Área: ${this.calculateArea(polygon.points).toFixed(3)} m²\n`;
          const children = this.polygonHierarchy.get(polygon.id) || [];
          if (children.length > 0) {
            hierarchyText += ` Hijos:\n`;
            children.forEach(childId => {
              const child = this.polygons.find(p => p.id === childId);
              if (child) {
                hierarchyText += ` ↳ 📄 ${child.name} (${this.calculateArea(child.points).toFixed(3)} m²)\n`;
              }
            });
          }
          const divisions = this.polygonDivisions.get(polygon.id) || [];
          if (divisions.length > 0) {
            hierarchyText += ` Divisiones pendientes: ${divisions.length}\n`;
          }
          hierarchyText += "\n";
        });
        alert(hierarchyText);
      }
    }
    // Initialize the application
    document.addEventListener("DOMContentLoaded", () => {
      new AdvancedPolygonDivider();
    });

    console.log('Sistema Profesional de División de Parcelas SAI - Listo');
  </script>
</body>

</html>